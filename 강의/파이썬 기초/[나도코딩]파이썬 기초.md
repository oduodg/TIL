# 1. 소개 & 환경설정

## 1-1. 소개

## 1-2. 환경설정

vscode

## 1-3. 파이썬 실행하기

# 2. 자료형

## 2-1~2-3. 숫자, 문자열, boolean 자료형

### 자료형

`숫자` : 정수 - 1, 2, 3 / 실수 - 1.0, 3.14

`문자` : "생일", "케이크

`불리안(boolean)` : 참(True), 거짓(False)

```python
#숫자 자료형
print(-10)
print(3.14)
print(100)

print(5+3) # 8 출력
print(2*8) # 16 출력 (주의 : x 가 아닌 * 예요)
print(3*(3+1)) # 12 출력

#문자열 자료형
print('풍선') # 작은 따옴표로 감싼 문자열 
print("나비") # 큰 따옴표로 감싼 문자열 
print("ㅋㅋㅋㅋㅋㅋㅋㅋㅋ") # 긴 문자열 
print("ㅋ"*9) # ㅋ 을 9번 출력

#boolean 자료형
print(5 > 10) # False 출력 
print(5 < 10) # True 출력

print(True) # True 
print(False) # False

print(not True) # False 출력 
print(not False) # True 출력 
print(not (5 > 10)) # True 출력
```

## 2-4. 변수

```python
name = "연탄이"
animal = "강아지"
age = 4
hobby = "산책"
is_adult = age >= 3

print("우리집 " + animal + "의 이름은 " + name + "에요")
print(name, "는 ", age, "살이며, ", hobby, "을 아주 좋아해요")
print(name + "는 어른일까요? " + str(is_adult))

👉🏻 우리집 강아지의 이름은 연탄이에요
연탄이는 4살이며, 산책을 아주 좋아해요
연탄이는 어른일까요? True
```

변수 특징

- 해당 변수를 사용하기 전에만 정의하면 OK
- 변수에 가장 마지막에 저장된 값을 사용
- '문자열 + 변수 + 문자열' 도 되고, '문자열, 변수, 문자열' 도 된다.  `+` 대신 `,` 를 사용하면 값과 값 사이에 **공백**이 하나 포함된다.
- boolean 자료형은 문자열과 조합할 때는 문자열로 바꿔주어야 한다. `str(is_adult)`
- 숫자 자료형을 문자열 자료형으로 바꿔서 출력하려면 `str(age)`

## 2-5. 주석

- 한 줄 주석은 `#`
- 여러 줄 주석은 `''' 주석 내용 '''`

# 3. 연산자

## 3-1. 연산자

[연산자](https://www.notion.so/b2a4669e67464c5f935b0ab74c472682)

연속적인 수식에 대해서도 연산 가능

```python
print(5 > 4 > 3) #(5 > 4)도 참이고 (4 > 3)도 참이므로 True
print(5 > 4 > 7) # (5 > 4) 는 참이지만 (4 > 7) 은 거짓이므로 False
```

이 때 a > b > c 연산은 a > b and b > c 연산과 동일하게 동작한다. 참고로 만약 a > b 가 거짓이라면 이후의 수식 결과와 상관 없이 항상 거짓이 되므로 b > c 연산은 수행하지 않는다.

## 3-2. 간단한 수식

`변수명 = 변수명 + 값` 을 간단하게 하면 `변수명 += 값`

(더하기 뿐 아니라 다른 연산자들도 같은 방식으로 적용가능)

## 3-3. 숫자처리함수

파이썬에서는 기본적으로 다음과 같은 여러 숫자 처리 함수를 제공해준다.

[숫자 처리 함수](https://www.notion.so/fb7d42f9ee2046f78e9666e791972deb)

[math 모듈](https://www.notion.so/6b5684c22a214e71946b63089ea5d794)

`모듈` 은 어떤 기능들을 모아놓은 파이썬 파일을 의미한다.

코드 내에서 모듈의 기능들을 가져다 쓰기 위해서는 아래와 같은 형태의 구문을 적어야 한다.

from *모듈이름* import *사용할 무언가*

```python
from math import * # math 모듈 내의 모든 내용을 가져다 쓰겠다는 의미

print(floor(4.99)) # 4.99 의 내림 = 4
print(ceil(3.14)) # 3.14 의 올림 = 4
print(sqrt(16)) # 16 의 제곱근 = 4
```

또 다른 방법

import *모듈이름*

단, 이 때는 모듈이름과 점(.)을 함께 적어야 한다.

```python
import math # math 모듈을 가져다 쓰겠다는 의미

print(math.floor(4.99)) # math. 과 함께 사용
print(math.ceil(3.14))
print(math.sqrt(16))
```

## 3-4. 랜덤함수

파이썬에는 무작위로 어떤 수를 뽑아주는 random 모듈이 있다.

```python
from random import * # random 모듈에서 모든 것들을 가져다 쓰겠다는 의미
print(random()) # 0.0 이상 1.0 미만의 임의의 값 생성

print(random() * 10) # 0.0 이상 10.0 미만의 임의의 값 생성
print(int(random() * 10)) # 0 이상 10 미만의 임의의 정수 값 생성
print(int(random() * 10) + 1) # 1 이상 10 이하 (11 미만) 의 임의의 정수 값 생성
```

1부터 45까지의 범위를 가지는 로또 번호를 뽑기 위해서는

```python
print(int(random() * 45) + 1) # 1 이상 46 미만의 임의의 정수 값 생성
```

보다 쉽게 원하는 범위 내의 랜덤 수를 뽑는 함수들

[랜덤 함수](https://www.notion.so/ba1260e275b0448bb58228e139ffbdb7)

# 4. 문자열 처리

## 4-1. 문자열

`문자열` 이란 문자들의 집합을 의미한다. 파이썬에서는 작은 따옴표 또는 큰 따옴표로 감싸서 문자열을 나타냄.

```python
sentence3 = """
나는 소년이고,
파이썬은 쉬워요
"""
print(sentence3) # 큰 따옴표 대신 작은 따옴표 3개씩으로 감싸도 돼요
```

문장 앞에 변수가 없으면 주석으로 인식된다는 점 주의! 

혼란을 줄이기 위해 가급적 주석은 작은 따옴표, 문자열은 큰 따옴표 사용을 권장.

## 4-2. 슬라이싱

여러 문자의 집합으로 구성된 문자열(또는 리스트 등)은 n번째 인덱스에 있는 문자(또는 데이터) 하나만을 가져올 수 있다.

→ `변수명[인덱스]`

인덱스는 1이 아닌 0부터 시작한다는 것 주의!

**슬라이싱: `변수명[시작인덱스:종료인덱스]`**

시작인덱스 값은 포함하고, 종료인덱스 값은 포함하지 않는다.(종료인덱스의 직전 값까지 포함)

`변수명[:인덱스]` :처음부터 인덱스 직전까지 슬라이싱

`변수명[인덱스:]` :인덱스부터 끝까지 슬라이싱

`변수명[:]` :처음부터 끝까지 슬라이싱

`변수명[인덱스의 음수값:]` :뒤에서 부터 슬라이싱 하기

*맨 처음의 인덱스는 [0], 맨 뒤의 인덱스는 [-1] 이라는 점 주의

## 4-3. 문자열처리함수

문자열을 편리하게 다루기 위한 함수

[문자열 관련 함수](https://www.notion.so/f89c737f7db64ffa904bf14932f5cd22)

```python
python = "Python is Amazing"

print(python.lower()) # python is amazing
print(python.upper()) # PYTHON IS AMAZING
print(python[0].isupper()) # True : 0 번째 인덱스의 값이 대문자인지 확인
print(len(python)) # 17 : 띄어쓰기를 포함한 문자열의 전체 길이 (length)
print(python.replace("Python", "Java")) # Java is Amazing

index = python.index("n") # 처음으로 발견된 n 의 인덱스
print(index) # 5 : Python 의 n
index = python.index("n", index + 1) # 6 번째 인덱스 이후에 처음으로 발견된 n 의 인덱스 
print(index) # 15 : Amazing 의 n

find = python.find("n") # 처음으로 발견된 n 의 인덱스
print(find) # 5 : Python 의 n
find = python.find("n", find + 1) # 6 번째 인덱스 이후에 처음으로 발견된 n 의 인덱스 
print(find) # 15 : Amazing 의 n

print(python.index("Java")) # Java 가 없기 때문에 에러가 발생하며 프로그램 종료
print(python.find("Java")) # Java 가 없으면 -1 을 반환(출력)하며 프로그램 계속 수행

print(python.count("n")) # 2 : 문자열 내에서 n 이 나온 횟수
```

## 4-4. 문자열포맷

```python
print("a" + "b") # ab
print("a", "b") # a b
```

이외에도 다양한 포맷으로 문자열을 출력하는 방법이 있다.

### 첫 번째 방법, %

**print("문자열 %d 문자열" % 정수)**

**print("문자열 %c 문자열" % 문자)**

**print("문자열 %s 문자열" % 문자열)**

```python
# 방법 1

print("나는 %d살입니다." % 20) # 나는 20살입니다
print("나는 %s을 좋아합니다." % "파이썬") # 나는 파이썬을 좋아합니다.
print("Apple 은 %c로 시작해요." % "A") # Apple 은 A로 시작해요.

print("나는 %s살입니다." % 20) # 나는 20살입니다 (%s 로도 정수값 표현 가능)

## 문자열 내에 2개 이상의 값 넣기
print("나는 %s색과 %s색을 좋아해요." % ("파란", "빨간")) # 나는 파란색과 빨간색을 좋아해요.
```

### 두 번째 방법, .format()

**print("문자열 {} 문자열" .format(값))**

```python
# 방법 2

print("나는 {}살입니다.".format(20)) # 나는 20살입니다.
print("나는 {}색과 {}색을 좋아해요.".format("파란", "빨간")) # 나는 파란색과 빨간색을 좋아해요
print("나는 {0}색과 {1}색을 좋아해요.".format("파란", "빨간")) # 나는 파란색과 빨간색을 좋아해요
print("나는 {1}색과 {0}색을 좋아해요.".format("파란", "빨간")) # 나는 빨간색과 파란색을 좋아해요
```

### 세 번째 방법, format(변수=값)

**print("문자열 {변수} 문자열" .format(변수=값))**

문자열 내에 {이름} 과 같이 넣어두고, 마치 변수를 사용하는 것처럼 .format 내에서 이름과 값을 정의해두면, 그 이름에 해당하는 부분에 값을 집어넣게 된다.

```python
# 방법 3

print("나는 {age}살이며, {color}색을 좋아해요.".format(age=20, color="빨간"))
# 나는 20살이며, 빨간색을 좋아해요

print("나는 {age}살이며, {color}색을 좋아해요.".format(color="빨간", age=20))
# 나는 20살이며, 빨간색을 좋아해요 (.format 뒤에 순서를 변경해도 괜찮아요)
```

### 네 번째 방법, f-string

문자열 앞에 f 를 추가해주면, 앞에서 선언된 변수 이름을 그대로 사용할 수 있다. 예제처럼 age 와 color 라는 변수를 선언하고, 문장 안에서 {age}, {color} 와 같이 중괄호로 둘러싼 변수 이름을 적으면 코드가 보다 간결해진다.

```python
# 방법 4 (파이썬 버전 3.6 부터 가능)

age = 20
color = "빨간"
print(f"나는 {age}살이며, {color}색을 좋아해요.") # 나는 20살이며, 빨간색을 좋아해요.
```

## 4-5. 탈출문자

탈출문자는 역슬래시(\)와 함께 어떤 문자를 사용함으로써 문장 내에서 원하는 값을 처리할 수가 있다.

### 문장을 두 줄로 찍기

`\n` 는 문장 내에서 줄바꿈 역할을 수행한다.

```python
print("백문이 불여일견\n백견이 불여일타")
# 백문이 불여일견
# 백문이 불여일타
```

### 따옴표 출력하기

따옴표 앞에 `\` 를 붙여준다.

```python
print("저는 \"나도코딩\"입니다.") # 저는 "나도코딩"입니다.
print("저는 \'나도코딩\'입니다.") # 저는 '나도코딩'입니다.
```

### 폴더나 파일의 경로 출력하기

\를 출력하기 위해서는 \\를 입력한다.

```python
print("C:\\Users\\Nadocoding\\Desktop\\PythonWorkspace>") 
# C:\Users\Nadocoding\Desktop\PythonWorkspace>
```

문자열 앞에 r을 넣는 방법도 있다. 그러면 문자열 내에서 어떤 값이 포함되어 있든지 개의치 않고 그대로 출력한다. 탈출문자가 포함되어 있어도 말이다.

```python
print(r"C:\Users\Nadocoding\Desktop\PythonWorkspace>") # raw string
```

### \r, \b, \t

```python
print("Red Apple\rPine") # PineApple
print("Redd\bApple") # RedApple
print("Red\tApple") # Red     Apple
```

`\r` 은 커서를 맨 앞으로 이동시키는 역할을 한다. "Pine"의 P를 출력하기 이전에 커서를 맨 앞으로, 즉 "Red" 앞으로 이동시켜서 마치 "Red"를 덮어쓰는 효과를 낸다.

`\b` 는 키보드의 백스페이스와 같은 역할을 한다. 즉 앞 글자 하나를 삭제한다.

`\t` 는 키보드의 탭(Tab)과 같이 여러 칸(보통 8칸 단위)을 띄어주는 역할을 한다.

# 5. 자료구조

## 5-1. 리스트

리스트를 사용하는 방법은 대괄호 속에 원하는 값들을 콤마로 구분하여 넣어주면 된다.

```python
subway = ["유재석", "조세호", "박명수"]
print(subway) # ['유재석', '조세호', '박명수']

# 조세호씨가 몇 번째 칸에 타고 있는가?
print(subway.index("조세호")) # 1 (인덱스는 0부터 시작한다는 것, 기억나시죠?)

# 하하씨가 다음 정류장에서 다음 칸에 탐
subway.append("하하")
print(subway) # ['유재석', '조세호', '박명수', '하하']

# 정형돈씨를 유재석 / 조세호 사이에 태움
subway.insert(1, "정형돈") # 인덱스 1 위치에 삽입
print(subway) # ['유재석', '정형돈', '조세호', '박명수', '하하']

# 지하철에 있는 사람을 한 명씩 뒤에서 꺼냄
print(subway.pop()) # 하하 내림
print(subway) # ['유재석', '정형돈', '조세호', '박명수']

print(subway.pop()) # 박명수 내림
print(subway) # ['유재석', '정형돈', '조세호']

print(subway.pop()) # 조세호 내림
print(subway) # ['유재석', '정형돈']

# 같은 이름의 사람이 몇 명 있는지 확인
subway.append("유재석") # 설명을 위해 유재석씨를 맨 뒤에 태울게요
print(subway) # ['유재석', '정형돈', '유재석']
print(subway.count("유재석")) # 유재석씨가 2명이 있네요!
```

`index()` :리스트에서 원하는 값의 인덱스 찾기

`append()` :리스트의 맨 마지막에 데이터 추가하기

`insert(index, value)` :원하는 인덱스 위치에 데이터 추가하기

`pop()` :맨 뒤에 있는 데이터 하나씩 빼기

`count()` :리스트 내에 같은 값이 몇 개 있는지

```python
num_list = [5, 2, 4, 3, 1]

num_list.sort() # 정렬
print(num_list) # [1, 2, 3, 4, 5]

num_list.reverse() # 순서 뒤집기
print(num_list) # [5, 4, 3, 2, 1]

# 모두 지우기
num_list.clear()
print(num_list) # []
```

`sort()` :오름차순 정렬

`reverse()` :리스트 거꾸로 뒤집기

`clear()` :리스트 내의 데이터 모두 지우기

```python
mix_list = ["조세호", 20, True] # 다양한 자료형을 함께 사용할 수 있어요
print(mix_list) # ['조세호', 20, True]

num_list = [5, 2, 4, 3, 1] # num_list 값 다시 정의
num_list.extend(mix_list) # 리스트 확장
print(num_list) # [5, 2, 4, 3, 1, '조세호', 20, True]
```

`extend()` :리스트 두개 합치기

(ex. list1.extend(list2)라면 list1의 뒤쪽에 list2의 값이 합쳐짐)

## 5-2. 사전

사전은 `key`와 `value`가 쌍으로 이루어져 있다. 영한 사전에서는 영어 단어를 key, 단어의 뜻을 value 라고 생각하면 된다.

사전은 중괄호{ }로 둘러싸서 정의하고, key와 value는 콜론(:)으로 구분짓는다. 2개 이상의 데이터는 리스트와 마찬가지로 콤마(,)로 구분한다.

{ key1 : value1, key2 : value2, ... }

```python
# 사전 형태의 사물함인 cabinet 정의
# 유재석에게는 3번 사물함 열쇠를, 김태호에게는 100번 사물함 열쇠를 줌/
cabinet = {3: "유재석", 100: "김태호"}

# 각 사물함이 누구 것인지 확인하자!
print(cabinet[3]) # 유재석 -> key 3 에 해당하는 value
print(cabinet[100]) # 김태호 -> key 100 에 해당하는 value

#대괄호가 아닌 get() 함수 이용
print(cabinet.get(3)) # 유재석 -> key 3 에 해당하는 value
```

### 대괄호와 get() 비교

정의되지 않은 key 전달시

- 대괄호 → 에러, 프로그램 종료
- get() → None 반환, 프로그램 계속 실행

### get() 활용

```python
print(cabinet.get(5, "사용 가능")) # key 에 해당하는 값이 없는 경우 기본 값을 사용
```

### key 값이 사전 자료형에 정의되어 있는지 여부 확인

```python
# 사전 자료형에 값이 있는지 여부 확인
print(3 in cabinet)  # True
print(5 in cabinet)  # False
```

```python
# key 는 정수형이 아닌 문자열도 가능
cabinet = {"A-3": "유재석", "B-100": "김태호"}
print(cabinet["A-3"]) # 유재석
print(cabinet["B-100"]) # 김태호
```

### key, value 업데이트 및 추가

대괄호를 이용하여 값을 설정한다.

`dict[key] = value`

```python
# 업데이트 또는 추가
print(cabinet) # {'A-3': '유재석', 'B-100': '김태호'}
cabinet["A-3"] = "김종국" # key 에 해당하는 값이 있는 경우 업데이트
cabinet["C-20"] = "조세호" # key 에 해당하는 값이 없는 경우 신규 추가
print(cabinet) # {'A-3': '김종국', 'B-100': '김태호', 'C-20': '조세호'}
```

### key, value 데이터 삭제

`del dict[key]`

```python
# 삭제
del cabinet["A-3"] # key "A-3" 에 해당하는 데이터 삭제
print(cabinet) # {'B-100': '김태호', 'C-20': '조세호'}
```

### 모든 key, value 확인하기

`keys()` :key 들만 출력

`values()` :value 들만 출력

`items()` : key, value 쌍으로 출력

```python
# key 들만 출력
print(cabinet.keys()) # dict_keys(['B-100', 'C-20'])

# value 들만 출력
print(cabinet.values()) # dict_values(['김태호', '조세호'])

# key, value 쌍으로 출력
print(cabinet.items()) # dict_items([('B-100', '김태호'), ('C-20', '조세호')])
```

### 사전 내 모든 데이터 삭제하기

`clear()`

```python
# 전체 삭제
cabinet.clear()
print(cabinet) # {}
```

## 5-3. 튜플

튜플은 리스트의 '읽기 전용 버전' 정도로 이해하면 좋다. 튜플은 처음 정의할 때를 제외하고는 **데이터 변경이나 추가, 삭제 등이 불가**하다. 대신 리스트보다는 속도가 빠르다.

튜플은 소괄호를 이용하여 정의한다.

(value1, value2, ...)

```python
menu = ("돈까스", "치즈까스")
print(menu[0]) # 돈까스
print(menu[1]) # 치즈까스

#튜플 형태로 한 줄에 여러 변수의 값 선언하기
(name, age, hobby) = ("김종국", 20, "코딩")
print(name, age, hobby) # 김종국 20 코딩
```

## 5-4. 세트

세트(set, 집합)는 **중복을 허용하지 않으며, 데이터의 순서도 보장하지 않는다.**

수학에서 배우는 것과 동일하게 중괄호를 이용하여 선언한다.

{value1, value2, ...}

또는 set() 함수를 이용하는 방법도 있다. set()함수를 이용할 때는 인자가 1개만 들어갈 수 있는 것에 주의.

```python
mudo = set(["유재석", "박명수"]) # ["유재석", "박명수"]라는 리스트 1개가 인자로 들어감.
mcyoo =  set("유재석")

mudo = set("유재석", "박명수") # TypeError: set expected at most 1 argument, got 2
```

중복을 허용하지 않으므로 같은 값은 여러 번 적어도 딱 한 번만 들어간다.

```python
my_set = {1, 2, 3, 3, 3} # 중복을 허용하지 않으므로 3은 1번만 들어감
print(my_set) # {1, 2, 3}
```

### 교집합

`&` , `intersection()`

```python
java = {"유재석", "김태호", "양세형"} # 자바 개발자 집합
python = set(["유재석", "박명수"]) # 파이썬 개발자 집합

# 교집합 (java 와 python 을 모두 할 수 있는 개발자)
print(java & python) # {'유재석'}
print(java.intersection(python)) # {'유재석'}
```

### 합집합

`|` , `union()`

```python
# 합집합 (java 또는 python 을 할 수 있는 개발자)
print(java | python) # {'박명수', '유재석', '김태호', '양세형'}
print(java.union(python)) # {'박명수', '유재석', '김태호', '양세형'}
```

*주의할 점

집합은 순서를 보장하지 않으므로 집합 내 데이터들의 출력 순서는 실행할 때마다 달라질 수 있다.

### 차집합

`-` , `difference()`

```python
# 차집합 (java 는 할 수 있지만 python 은 할 줄 모르는 개발자)
print(java - python) # {'양세형', '김태호'}
print(java.difference(python)) # {'양세형', '김태호'}
```

### 데이터 추가

`add()`

```python
# python 개발자 추가 (기존 개발자 : 박명수, 유재석)
python.add("김태호")
print(python) # {'박명수', '유재석', '김태호'}
```

### 데이터 삭제

`remove()`

```python
# java 개발자 삭제 (기존 개발자 : 유재석, 김태호, 양세형)
java.remove("김태호")
print(java) # {'유재석', '양세형'}
```

## 5-5. 자료구조의 변경

`type()` :데이터의 형태 확인

```python
menu = {"커피", "우유", "주스"}
print(menu, type(menu)) # menu 의 type 정보 : set

menu = list(menu) # 리스트 형태로 변환
print(menu, type(menu)) # menu 의 type 정보 : list

menu = tuple(menu) # 튜플 형태로 변환
print(menu, type(menu)) # menu 의 type 정보 : tuple

menu = set(menu) # 세트 형태로 변환
print(menu, type(menu)) # menu 의 type 정보 : set
```

## 5-6. random 모듈의 shuffle()과 sample()의 활용

`shuffle()` :단어 뜻 그대로 섞어주는 역할을 하는 함수

`sample()` :리스트 내에서 원하는 갯수의 값을 뽑는 동작을 수행하는 함수(한 번에 원하는 갯수만큼의 번호를 중복 없이 뽑을 수 있다.)

shuffle(list) → list 내의 값들을 무작위 순서로 섞음

sample(list, 1) → list 내의 값 중 1개의 값을 랜덤으로 뽑음

# 6. 제어문

## 6-1. if

"첫 구매이면", "무슨 카드를 쓰면", "학생이면" 등등의 조건에 따라 동작이 달라지는 것, 이것을 프로그래밍에서 `분기` 라고 표현한다.

코드에서 분기는 if를 사용하며 기본적인 형식은 아래와 같다.

if 조건:

실행 명령문

- if 조건문의 끝에는 **콜론(:)**이 붙는다.
- if 조건에 만족할 때 실행해야 할 문장들은 if 위치를 기준으로 공백(스페이스) **4칸씩 들여쓰기**를 해야 한다.
- **elif**는 필요한 만큼 여러 번 사용할 수 있다. 마찬가지로 끝에 콜론(:)을 붙이고, 들여쓰기를 해야 한다.
- if와 elif 들의 모든 조건에 해당하지 않을 때 어떤 명령을 실행하기 위해서는 **else**를 사용한다.

```python
if 조건1:
    실행 명령문1
elif 조건2:
    실행 명령문2
elif 조건3:
    실행 명령문3
else:
    실행 명령문4 # 위 모든 조건들에 해당하지 않을 때 실행
```

`input()` :프로그램 실행 시점에 사용자로부터 어떤 값을 입력받는 용도로 사용한다. 사용자가 값을 입력하고 엔터를 치면 그 값은 항상 "문자열" 형태로 변수에 저장된다. 

- 숫자 3을 입력해도 문자열 "3"으로 인식한다는 점을 주의
- 정수형으로 변환하기 위해서는 input()을 int()로 감싸줄 것. `int(intput())`

## 6-2. for

프로그램에서 분기만큼이나 중요한 것이 바로 **반복**이다. 이 때 필요한 것이 바로 반복문이며, 처음 배워볼 반복문은 for문이다.

for 변수 in 반복대상:

실행 명령문1

실행 명령문2

...

- if와 마찬가지로 for 문장 끝에 **콜론(:)**을 붙이며 반복 대상이 되는 싱행 명령문들은 **들여쓰기**를 해서 구분한다.

## 6-3. while

for 문은 리스트와 같은 반복 대상에서 값을 하나씩 꺼내서 반복 작업을 수행하는 반면, while문은 조건이 만족하는 동안 끝없이 반복한다.

while 조건:

실행 명령문1

실행 명령문2

...

- 조건이 거짓(False)가 되면 while문을 벗어나게 된다.(일반적으로 while 문을 "탈출"한다고 표현함)

## 6-4. continue와 break

`continue` :더 이상 아래 명령들을 실행하지 않고 다음 반복대상으로 넘어갈 때 사용한다.

`break` :즉시 반복문을 탈출하는 데 사용한다.

```python
absent = [2, 5] # 결석한 학생 출석번호
no_book = [7] # 책을 가져오지 않은 학생 출석번호

for student in range(1, 11): # 출석번호 1~10번
    if student in absent: # 결석했으면 책을 읽지 않고 다음 학생으로 넘어가기
        continue
    elif student in no_book: # 책을 가져오지 않았으면 바로 수업 종료 (반복문 탈출)
        print("오늘 수업 여기까지. {0}는 교무실로 따라와".format(student))
        break
    print("{0}, 책을 읽어봐".format(student))
```

```python
1, 책을 읽어봐
3, 책을 읽어봐
4, 책을 읽어봐
6, 책을 읽어봐
오늘 수업 여기까지. 7는 교무실로 따라와
```

## 6-5. 한 줄 for

파이썬에서는 아주 간결하게 한 줄로 된 for 반복문을 이용할 수 있다. 반복 대상 항목을 하나씩 순회하면서 변수에 저장하고 그 변수를 사용자가 원하는 동작을 수행하는 방식이다.

[변수로 어떤 동작 for 변수 in 반복대상]

```python
students = [1, 2, 3, 4, 5]
print(students) # [1, 2, 3, 4, 5]

# 한 줄 for 를 이용하여 각 항목에 100 을 더함
students = [i + 100 for i in students]
print(students) # [101, 102, 103, 104, 105]
```

students = [i + 100 for i in students]

→ 반복대상인 students 리스트에서 하나씩 값을 가져와서 i 라는 변수에 저장하고, 그 변수를 활용하여 i + 100 이라는 명령을 실행한 값들을 새로운 리스트로 만들어서 students에 집어넣으라는 의미.

→ 정리하면, 반복 대상 항목의 값들에 대해서 각각 어떤 동작을 수행하고, 수행한 결과들을 모아서 새로운 리스트로 만드는 것이다.

*주의할 점

이 때 사용된 i 는 사용자가 임의로 사용한 이름이며, 다른 이름을 사용해도 된다. 다만 그 이름이 "변수" 위치와 "변수로 어떤 동작" 위치에 동일하게 사용되어야 한다는 점을 주의할 것.

```python
# (예)

students = [x + 100 for x in students]

students = [name + 100 for name in students]
```

### 이름의 길이 정보를 가져오는 리스트로 변형

```python
students = ["Iron man", "Thor", "I am groot"]
print(students) # ["Iron man", "Thor", "I am groot"]

# 한 줄 for 를 이용하여 각 이름의 길이 정보로 변환
students = [len(i) for i in students]
print(students) # [8, 4, 10]
```

### 이름을 모두 대문자로 변형

```python
students = ["Iron man", "Thor", "I am groot"]
print(students) # ["Iron man", "Thor", "I am groot"]

# 한 줄 for 를 이용하여 각 이름을 대문자로 변경
students = [i.upper() for i in students]
print(students) # ['IRON MAN', 'THOR', 'I AM GROOT']
```

# 7. 함수
### 함수 정의

print(), len(), append(), pop() 이런 것들이 모두 함수이며, **def** 라는 글자와 함께 **함수 이름**, 그리고 **괄호()** 로 구성된다. 그리고 함수의 동작을 정의하는 부분도 필요하므로 뒤에 **콜론(:)** 을 적어준다.

def 함수이름():

실행 명령문1

실행 명령문2

....

### 함수 호출

함수를 사용할 때는 함수 이름과 괄호()를 함계 적어주면 되고, 이 때 "함수를 호출한다"라고 표현한다.

```python
def open_account(): # 함수 정의
    print("새로운 계좌가 생성되었습니다.")

open_account() # 앞에서 정의된 open_account() 함수 호출
```

### 함수명 짓기

- 함수의 이름은 그 함수의 동작을 대표하는 것으로 짓는 게 좋다.
- 문자로 시작하며 각 단어들(open, account) 을 밑줄(_) 로 구분하는 형태라면 대부분 사용 가능하다.
- 보통 변수는 명사, 함수는 동사를 이용한다.

(예)

변수 : account_number → 계좌 번호 (명사)

함수 : open_account() → 계좌를 개설하다 (동사)

## 7-2. 전달값과 반환값

함수에는 `전달값`, `동작`, `반환값`이라는 3가지 요소가 있다. 전달값과 반환값은 옵션이기 때문에 이 둘은 있는 함수도 없는 함수도 있다.

함수 이름 옆의 괄호() 에는 필요한 갯수 만큼의 전달값이 들어가며, 함수 내에서는 이 전달값들을 활용한 어떤 명령을 수행하고 나서 맨 아래에 있는 return 을 통해서 값을 반환해준다. 전달값과 마찬가지로 반환값 또한 2개 이상이 될 수도 있다.

def 함수이름(전달값, 전달값2, ...):

실행 명령문1

실행 명령문2

...

return 반환값1, 반환값2

```python
def deposit(balance, money): # 입금
    print("입금이 완료되었습니다. 잔액은 {0} 원입니다.".format(balance + money))
    return balance + money # 입금 후 잔액 정보 반환
    
balance = 0 # 최초 잔액
balance = deposit(balance, 1000) # 1000원 입금
print(balance) # 현재 잔액
```

 이 때, 1000원을입금하는 부분인 deposit(balance, 1000)에서의 balance는 바로 윗줄에 선언된 잔액 정보를 가지는 변수이며, 1000이 입금액이 된다. 즉, deposit 함수를 호출하는데 0과 1000이라는 2개의 값을 전달하는 셈이 된다.

함수를 정의할 때 전달값을 받기 위해 사용되는 balance, money 와 같은 변수를 `매개변수(parameter)` 라고 부르기도 합니다.

그리고 함수 정의부분에 있는 deposit(balance, money)에서의 balance는 함수 내에서 사용할 변수 이름이 되는데, 호출할 때 사용된 balance와 똑같은 이름이 사용되기는 했지만 둘은 사실 같은 변수는 아니다. 그저 처음 전달받은 값인 0을 저장하는 새로운 변수일 뿐이다.

함수 내의 동작이 완료되고 나서 마지막으로 return balance + money 를 통해 값을 반환해주는데, 이렇게 반환해주는값은 함수 밖에 정의된 balance 함수에 저장된다. 마치 변수에 어떤 값을 저장하는 것처럼, 함수를 호출하고 나서 반환해주는 값을 저장하게 되는 것이다.

```python
balance = 0 # balance 변수에 0 이라는 값을 저장
balance = deposit(balance, 1000) # balance 변수에 deposit() 함수의 반환값을 저장
```

만약 앞에 balance = 란 부분이 없다면?

```python
deposit(balance, 1000)
```

deposit(balance, 1000함수는 어떤 값을 반환해주기는 하는데 아무 변수도 지정하지 않았으므로 그 값은 어디에서도 사용할 수 없게 된다. 그렇기 때문에 반환값이 있는 함수를 이용하며 반환값을 사용하고자 할 때에는 반드시 값을 반환 받을 변수를 명시해야 한다.

- 함수 내에서 return 부분이 실행되고 나면 값을 반환함과 동시에 함수는 탈출하게 된다.
- 그러므로 return 밑에 어떤 코드가 있다면 이 부분은 실행되지 않는다는 점 주의!
- 마치 반복문을 탈출하게 해주는 break 와 비슷하다고 이해하면 된다.

### 변수 2개에 반환값 2개 각각 저장하기

```python
def withdraw_night(balance, money): # 저녁에 출금
    commission = 100 # 출금 수수료 100원
    return commission, balance - money - commission # 튜플 형식으로 반환
    
balance = 0 # 최초 잔액
balance = deposit(balance, 1000) # 1000원 입금

# 저녁에 출금 시도
commission, balance = withdraw_night(balance, 500)
print("수수료 {0} 원이며, 잔액은 {1} 원입니다.".format(commission, balance))
```

return 부분을 살펴보면 수수료를 저장하고 있는 commission 과 출금 후 잔액인 balance - money - commission (기존 잔액에서 출금액과 수수료를 뺀 금액) 을 콤마로 구분하여 함께 적었다. 바로 튜플 형태인데, 콤마로 구분하여 2개 이상의 값을 적으면 함수를 호출하는 쪽에서도 콤마로 구분된 여러 개의 변수에 값을 한 번에 저장할 수 있게 된다. 예제에서는 좌항의 commission 과 balance 에 각각 수수료와 잔액 정보를 저장하고 있다.

```python
commission, balance = withdraw_night(balance, 500) # 튜플 형식으로 반환된 2개의 값을 각 변수에 저
```

## 7-3. 기본값

함수를 호출할 때 기본으로 사용할 값을 정의해줄 수 있다. 모든 전달값에 대해서 일일이 적지 않아도 되는 이점이 있다.

```python
def profile(name, age=17, main_lang="파이썬"): # 전달값을 따로 받지 않을때 기본으로 사용할 값
    print("이름 : {0}\t나이 : {1}\t주 사용 언어 : {2}".format(name, age, main_lang))
        
profile("유재석")
profile("김태호")
```

물론 기본값이 있다고 해도 다음과 같이 필요한 전달값을 포함하면 기본값을 정의하지 않았을 때와 동일하게 사용할수 있다.

```python
profile("유재석") # age, main_lang 을 기본값으로 사용
profile("유재석", 20) # main_lang 을 기본값으로 사용
profile("유재석", 20, "파이썬") # 기본값 사용하지 않음
```

## 7-4. 키워드 인자

함수를 호출하는 방법 중에 키워드 인자를 이ㅛㅇ하는 방법도 있다.

```python
def profile(name, age, main_lang): # 키워드 인자 : name, age, main_lang
    print(name, age, main_lang)

# profile("유재석", 20, "파이썬")
# profile("김태호", 25, "자바")

profile(name="유재석", main_lang="파이썬", age=20)
profile(main_lang="자바", age=25, name="김태호")
```

함수를 호출하는 곳에서의 전달값(인자)의 순서와 상관없이 순서대로 값들이 잘 출력된다.

```python
# 출력
유재석 20 파이썬
김태호 25 자바
```

키워드 인자는 보통 어떤 함수에 전달값들이 많고 기본값들이 잘 정의되어 있을 때, 대부분 기본값을 쓰고 필요한 부분만 콕 찍어서 값을 전달하고자 하는 경우에 유용하다. 무엇보다 순서에 구애받지 않으므로 함수에서 사용 가능한 키워드의 종류만 알고 있따면 아주 편리하게 사용 가능하다는 장점이 있다.

*주의할 점

함수를 호출할 때 일반적인 전달값과 키워드 인자를 함께 사용하는 경우에는 반드시 일반 전달값들을 순서대로 먼저 적고 나서 키워드 인자들을 적어야 한다. 그리고 키워드 인자에 오타가 있는 경우 에러가 발생할 수 있으니 주의!

```python
#(예)

profile("유재석", age=20, main_lang="파이썬") # (O) 올바른 함수 호출 방법 (일반 전달값을 먼저 작성)

profile(name="김태호", 25, "파이썬") # (X) 잘못된 함수 호출 방법 (키워드 인자 먼저 작성 후 일반 전달값 작성)
```

## 7-5. 가변인자

가변인자란 말 그대로 변할 수 있는 인자를 의미한다.

def 함수이름(전달값1, 전달값2, ..., `*가변인자`):

실행 명령문1

실행 명령문2

...

return 반환값

가변인자는 앞에 `*` 표시를 하나 추가해주면 된다.

```python
def profile(name, age, *language): # 언어 정보를 전달하고 싶은 갯수 만큼 전달 가능    
    print("이름 : {0}\t나이 : {1}\t".format(name, age), end=" ")
    
    # print(type(language)) # tuple
    for lang in language:
        print(lang, end=" ") # 언어들을 모두 한 줄에 표시
    print() # 줄바꿈 목적
```

가변인자인 language의 타입을 확인해보면 튜플임을 알 수 있다. 그렇기 때문에 for문을 사용하면 가변인자로 전달받은 값들을 하나씩 반복하면서 사용할 수 있다. 각 언어들을 한 줄에 표시하기 위해 이번에도 end=""를 추가했고, 모든 언어 정보를 출력하고 나면 줄바꿈을 해주기 위해 비어 있는 print()를 적어준다.

```python
profile("유재석", 20, "Python", "Java", "C", "C++", "C#", "JavaScript") # JavaScript 추가
profile("김태호", 25, "Kotlin", "Swift")
```

```python
# 이름 : 유재석   나이 : 20        Python Java C C++ C# JavaScript
# 이름 : 김태호   나이 : 25        Kotlin Swift
```

## 7-6. 지역변수와 전역변수

`지역 변수` :함수 내에서만 쓸 수 있는 변수

`전역 변수` :모든 곳에서 쓸 수 있는 변수

`global` :함수 내에서 전역변수를 사용하기 위한 키워드, 전역 공간에 선언된 변수를 그대로 사용하며 그 값은 직접 변경할 수도 있다.

```python
gun = 10

def checkpoint(soldiers):
    global gun # 전역공간에 있는 gun 이라는 변수를 사용
    gun = gun - soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))

print("전체 총 : {0}".format(gun))
checkpoint(2)
print("남은 총 : {0}".format(gun))
```

```python
# 실행결과
전체 총 : 10
[함수 내] 남은 총 : 8
남은 총 : 8
```

### 전역변수가 없는 버전으로 만들기

전달값과 반환값을 적절히 활용하여 만들자.

```python
gun = 10

def checkpoint_ret(gun, soldiers): # 전체 총 수와 군인 수를 전달받음
    gun = gun - soldiers # 전달받은 gun 을 사용
    print("[함수 내] 남은 총 : {0}".format(gun))
    return gun

print("전체 총 : {0}".format(gun))
gun = checkpoint_ret(gun, 2) # gun 값을 함수에 전달
print("남은 총 : {0}".format(gun))
```

함수를 정의할 때 가급적 외부 상황은 몰라도 되도록 전달받은 값만 이용하게끔 작성하면 보다 간결하면서도 함수의 역할에 충실할 수 있다.
# 8. 입출력
## 8-1. 표준입출력

```python
print("Python", "Java")

print("Python" + "Java")
```

첫 번째 문장은 `콤마(,)` 로 문자열들을 구분하였고, 두 번째 문장은 `더하기(+)` 기호로 문자열들을 합쳤다.

```python
# 실행 결과
Python Java

PythonJava
```

`sep` :문자열들을 구분하는 방법을 사용자가 직접 정의할 수 있도록 해주는 기능(분리 기호를 의미하는 seperator의 줄임말)

```python
print("Python", "Java", sep=",") # 값들을 콤마(,)로 구분
print("Python", "Java", "JavaScript", sep=" vs ") # 값들을 " vs " 로 구분
```

```python
# 실행 결과
Python,Java
Python vs Java vs JavaScript
```

print()는 기본적으로 문장이 끝날 때마다 줄바꿈을 하기 때문에 연속적으로 2개 이상의 print()를 이용하면 각각의 줄에 내용이 출력된다. 하지만 이를 한 줄에 모두 엮어서 출력하려면 `end=" "`와 같이 하면 된다.

```python
print("Python", "Java", sep=",", end="?")
print("무엇이 더 재밌을까요?")
```

```python
# 실행 결과
Python,Java?무엇이 더 재밌을까요?

# end= 를 적지 않았을 때의 결과
Python,Java

무엇이 더 재밌을까요?
```

### 표준 출력과 표준 에러

```python
import sys # sys 모듈을 가져와서 사용하겠다는 의미
print("Python", "Java", files=sys.stdout) # 표준 출력
print("Python", "Java", files=sys.stderr) # 표준 에러
```

```python
# 출력 결과
Python Java
Python Java
```

file= 에 `sys.stdout (Standard Output, 표준 출력)` 와 `sys.stderr (Standard Error, 표준 에러)` 를 각각 넣었는데, 출력결과는 크게 달라보이지 않는다. 보다 큰 규모의 파이썬 프로젝트를 진행하게 되면 필요해질텐데, `stdout` 과 `stderr` 은 사용하는 용도가 조금 다르다.

보통 프로그램 수행 과정에서 몇 시에 어떤 작업을 어떤 식으로 수행하고 있으며 그 결과는 어떠한지 등의 정보를 가지는 로그를 남길 때 `stdout` 은 일반적인 내용을, `stderr` 는 에러 발생 시 관련 내용을 출력하기 위해 사용할 수 있다. 이렇게 구분지어주면 프로그램이 의도치 않은 동작을 하는 경우에 에러 로그만 확인하면 보다 빠르게 상황 파악 및 조치가 가능해진다.

파이썬 기본편을 공부하는 시점에서는 이런 게 있구나 정도로만 이해하고 넘어가도 좋다.

### 왼쪽 정렬과 오른쪽 정렬

`ljust()` : l은 왼쪽(left)을 의미하며 함께 전달하는 숫자값 만큼 미리 공간을 확보하고 그 공간에 왼쪽 정렬을 한다.

`rjust()` : r은 오른쪽(right)을 의미하며, 오른쪽 정렬을 한다.

```python
scores = {"수학":0, "영어":50, "코딩":100}

for subject, score in scores.items():
    print(subject.ljust(8), str(score).rjust(4), sep=":")
```

```python
# 실행 결과
수학      :   0
영어      :  50
코딩      : 100
```

`zfile()` : 함께 전달해주는 숫자만큼의 공간을 확보하고 그 공간을 zero로, 즉 0으로 채워주는(fill) 동작을 한다.

```python
for num in range(1, 21): # 1~20 까지의 숫자
    print("대기번호 : " + str(num).zfill(3))
```

```python
# 실행 결과
대기번호 : 001
대기번호 : 002
대기번호 : 003

... 생략 ...

대기번호 : 018
대기번호 : 019
대기번호 : 020
```

### 표준 입력

input() 을 통해 입력받는 모든 값은 항상 **문자열** 형태로 저장되기 때문에 만약 10 과 같은 정수를 입력받고 이 값을 실제로 계산 목적으로 사용하려면 반드시 **int(input())** 와 같이 형을 바꿔줘야 한다.

## 8-2. 다양한 출력포맷

### 오른쪽/왼쪽 정렬 및 빈 자리 채우기

```python
print("{0}".format(500)) # {0} 위치에 500 값 출력
print("{0: >10}".format(500)) # 빈 자리는 비워두기, 우측 정렬, 10 칸의 공간 확보

print("{0: >+10}".format(500)) # 빈 자리는 비워두기, 우측 정렬, + 기호, 10 칸의 공간 확보
print("{0: >+10}".format(-500))

print("{0:_<10}".format(500)) # 빈 자리는 _ 로, 좌측 정렬, 10 칸의 공간 확보
```

```python
# 실행 결과
'''
500
       500
      +500
      -500
500_______
'''
```

### 1,000단위로 콤마 찍기

```python
print("{0:,}".format(100000000000)) # 3자리 마다 콤마 찍어주기
print("{0:+,}".format(100000000000)) # + 기호, 3자리 마다 콤마 찍어주기
print("{0:+,}".format(-100000000000))
```

```python
# 실행 결과
'''
100,000,000,000
+100,000,000,000
-100,000,000,000
'''
```

```python
# 빈 자리는 ^ 로, 좌측 정렬, + 기호, 30 칸의 공간 확보, 3자리 마다 콤마 찍어주기
print("{0:^<+30,}".format(100000000000))
# +100,000,000,000^^^^^^^^^^^^^^
```

### 소수점 출력하기

f는 실수형 자료(float)를 의미하는데 점(.)과 숫자(n)를 함께 적으면 소수점 n번째 자리까지 출력 해준다. 셋째자리에서 반올림하여 둘째자리까지 출력하려면 .2f라고 적으면 된다.

```python
print("{0:f}".format(5/3)) # 실수 값 출력
# 1.666667
print("{0:.2f}".format(5/3) # 소수점 둘째자리까지 출력
#1.67
```

지금까지 공부한 출력 포맷은 다음과 같은 순서로 { } 내에 사용자가 필요한 부분만 명시하는 방식으로 포맷을 정의할 수 있다.

{인덱스:[[빈자리채우기]정렬][기호][확보공간][콤마][.자릿수][타입]}

## 8-3. 파일입출력

프로그래밍에서 파일을 다룰 때는 일반적으로

1. **파일을 열고**
2. **파일에 어떤 내용을 쓰거나 읽고**
3. **파일을 닫는**

순서로 진행한다.

파일을 열기 위해서는 `open()` 이라는 함수를 이용하면 된다.

open("파일명", "열기 모드", encoding="인코딩")

2번째로 전달하는 **"열기 모드"** 에는 `읽기(read, "r")`, `쓰기(write, "w")`, `이어쓰기(append, "a")` 가 있다. 읽기는 말 그대로 이미 어떤 내용을 담고 있는 파일을 읽어오기 위한 모드이며, 파일에 어떤 내용을 쓰기 위해서는 쓰기나 이어쓰기 모드를 사용한다. 이 때 동일한 이름의 파일이 있는 경우 쓰기 모드는 그 파일을 덮어쓰게 되므로 기존 내용은 다 삭제가 되며, 이어쓰기 모드는 그 파일의 내용 맨 밑에 이어서 쓴다는 차이점이 있다.

`encoding`은 파일 내용으로 쓰는 언어와 관련된 것인데 일반적으로 **"utf-8"** 로 설정 해주면 한글을 포함한 내용을 다룰 때에도 문제가 없다.

```python
score_file = open("score.txt", "w", encoding="utf8") # score.txt 파일을 쓰기("w") 모드로 열기
print("수학 : 0", file=score_file) # score.txt 파일에 내용 쓰기
print("영어 : 50", file=score_file) # score.txt 파일에 내용 쓰기
score_file.close() # score.txt 파일 닫기
```

코드 마지막 줄에 close() 함수를 호출하는데, 파일을 열고 나면 반드시 닫아주어야 한다. 파일을 닫지 않으면 소스코드의 다른 위치에서 동일한 파일에 접근하려고 할 때 파일에 따라 문제가 발생할 수도 있다.

```python
score_file = open("score.txt", "a", encoding="utf8") # score.txt 파일을 쓰기("a") 모드로 열기
score_file.write("과학 : 80")
score_file.write("\n코딩 : 100") # write 는 줄바꿈 안해주기 때문에 탈출문자(\n)로 줄바꿈 추가
score_file.close()v
```

파일 변수에서 제공하는 `write()` 함수는 print() 와는 다르게 자동으로 줄바꿈을 해주지 않기 때문에 탈출문자(\n)를 통해서 줄바꿈을 추가한다.

```python
score_file = open("score.txt", "r", encoding="utf8") # score.txt 파일을 읽기("r") 모드로 열기
print(score_file.read()) # 파일 전체 읽어오기
score_file.close()
```

파일은 한 번에 모두 읽어올 수도 있지만 한 줄 한 줄 끊어서 읽어올 수도 있다. `readline()` 함수를 이용하면 한 줄 단위로 불러온다.

```python
score_file = open("score.txt", "r", encoding="utf8")
print(score_file.readline(), end="") # 줄별로 읽기. 한 줄 읽고 커서는 다음 줄로 이동
print(score_file.readline(), end="") # 줄바꿈 중복을 방지하기 위해 end="" 처리
print(score_file.readline(), end="")
print(score_file.readline(), end="")
score_file.close()
```

현재 파일에 쓰여진 각 문장은 끝에 줄바꿈을 포함하고 있기 때문에 print() 자체의 줄바꿈과 중복으로 실행되는 증상을 막기 위해서 각 문장마다 end=""로 처리했다.

```python
score_file = open("score.txt", "r", encoding="utf8")

while True:
    line = score_file.readline()
    if not line: # 더 이상 읽어올 내용이 없으면?
        break # 반복문 탈출
    print(line, end="") # 읽어온 줄 출력. 줄바꿈 중복을 방지하기 위해 end="" 처리
    
score_file.close()
```

대부분의 경우 파일이 총 몇 줄로 구성되었는지는 열어보기 전까지는 알 수 없다. 이 때는 while 반복문을 사용하여 읽으려는 줄이 있는 동안 계속 반복하여 읽어들이도록 할 수 있다. 더 이상 읽으려는 줄이 없을 때 반복문을 탈출하도록 하는 것이다.

while 반복문의 조건을 True 로 설정하였기 때문에 계속하여 반복 수행하게 되며, 매 단계마다 line 이라는 변수에 한 줄씩 읽어와서 내용이 있는지 확인하고 있으면 출력, 더 이상 읽어올 내용이 없으면 반복문이 탈출하게 되는 원리다.

```python
score_file = open("score.txt", "r", encoding="utf8")

lines = score_file.readlines() # 모든 줄을 읽어와서 list 형태로 저장
for line in lines:
    print(line, end="") # 읽어온 줄 출력. 줄바꿈 중복을 방지하기 위해 end="" 처리
    
score_file.close()
```

`readlines()` 는 파일 내 모든 줄을 읽어오는 함수를 이용하여 while 대신 for 문을 이용하여보다 수월하게 리스트 데이터를 순차적으로 읽어오도록 작성할 수 있다.

## 8-4. pickle

프로그램의 실행이 종료되고 나면 이 모든 데이터는 흔적도 없이 사라지게 된다. 그런데 만약 이 리스트 데이터를 또 사용해야 한다면 어떻게 할 수 있을까? 프로그램은 실행이 끝나버리면 모든 데이터가 사라지므로 끝나기 전에 어딘가 저장을 해야한다. 이 때 사용할 수 있는 것이 바로 `pickle` 이다. 

`pickle` : 프로그램에서 사용하고 있는 데이터를 파일 형태로 저장하거나 불러올 수 있게 해주는 모듈

먼저 pickle을 이용하여 데이터를 파일로 저장을 할 때는 `dump()`라는 함수를 사용한다. 첫 번째 전달값으로 **저장할 데이터**를, 두 번째 전달값으로는 **데이터를 저장할 파일**을 적어준다.

dump(data, dest_file)

### 예제

어떤 사람의 프로필 데이터를 만들고 저장하는 예제를 들어보자.

먼저 pickle 모듈을 가져다 쓰기 위해 import 를 한다.

이어서 파일을 하나 열 텐데 파일 이름은 "profile.pickle" 로 하고 쓰기 모드인 "w" 로 하는데, pickle 을 이용해서 저장되는 파일은 텍스트(text)가 아닌 **바이너리(binary) 형태**이다. 일반적인 한글, 영어, 숫자 등의 내용을 담고 있는게 텍스트 파일이라면 .jpg, .png 와 같은 이미지나 .mp3 와 같은 음악, 또는 .exe 와 같은 실행 파일 등이 바이너리 파일이다.

pickle 로 저장하는 파일 또한 바이너리 파일이기 때문에 open() 함수를 이용할 때 "w" 뒤에 "b" 를 붙여서 "**wb**" 라고 해야 올바르게 저장이 된다. 또한 데이터 내에 한글이 포함되어 있다 하더라도 별도의 encoding 은 지정할 필요가 없다.

```python
import pickle # pickle 모듈 가져다 쓰기

profile_file = open("profile.pickle", "wb") # 바이너리(binary) 형태로 저장
profile = {"이름":"박명수", "나이":30, "취미":["축구", "골프", "코딩"]}
print(profile)

pickle.dump(profile, profile_file) # profile 데이터를 file 에 저장
profile_file.close()
```

코드를 실행하면 profile 에 들어있는 데이터가 출력되고 워크스페이스 내에 profile.pickle 이라는 파일이 생긴 것을 확인할 수 있다. 이 파일은 바이너리 형태로 저장되었기 때문에 비주얼 스튜디오 코드나 파일 에디터 프로그램에서 열어도 그 내용을 올바르게 확인할 수는 없다.

사용하려는 모듈과 동일한 이름을 생성하면 import 시에 동일한 경로에 있는 파일을 먼저 인식하기 때문에 AttributeError가 난다.

이번에는 데이터가 정말 잘 저장되었는지 확인하기 위해 앞에서 만든 파일을 다시 불러올텐데, 이 때는 `load()` 함수를 이용하고 전달값으로는 파일을 작성하면 됩니다.

load(src_file)

먼저 파일을 열텐데 저장할 때와 마찬가지로 읽기 모드(r)에서도 **바이너리 파일**이기 때문에 "b" 를 붙여서 "**rb**" 라고 해야한다. load() 함수를 통해서 이 파일을 전달한다. 그러면 좌항에 있는 profile 변수에 파일에서 불러온 데이터를 그대로 저장하게 된다. 잘 불러왔는지 출력하고 나서 이번에도 close() 함수를 통해 파일을 닫아준다.

```python
profile_file = open("profile.pickle", "rb") # 읽을 때에도 바이너리(binary) 명시
profile = pickle.load(profile_file) # file 에 있는 정보를 불러와서 profile 에 저장

print(profile)
profile_file.close()
```

코드를 실행해보면 저장할 때와 동일한 데이터를 그대로 불러온 것을 확인할 수 있다.

```python
# 실행 결과
{'이름': '박명수', '나이': 30, '취미': ['축구', '골프', '코딩']}
```

## 8-5. with

파이썬에서는 `with` 란 것이 있는데, 이를 이용하면 파일을 열고 나서 close() 를 호출하지 않아도 자동으로 닫아주는 역할을 해준다.

with 작업 as 변수명:

실행 명령문1

실행 명령문2

...

with 뒤에 따라오는 작업이 바로 파일을 여는 opee() 함수가 들어가는 부분이다. open() 을 통해 열린 파일은 as 뒤에 있는 변수명으로 접근할 수 있다. if, for, while, def 와 같이 문장 끝에 콜론(:) 을 붙여주고, with 구문 내에서 실행할 명령문들은 반드시 들여쓰기를 해야 한다. 그리고 with 구문을 벗어나면 변수명은 사용할 수 없게 된다.

### 예제

```python
import pickle

with open("profile.pickle", "rb") as profile_file:
    print(pickle.load(profile_file))
```

실행해보면 데이터가 잘 출력된 것을 확인할 수 있다.

```python
with open("study.txt", "w", encoding="utf8") as study_file:
    study_file.write("파이썬을 열심히 공부하고 있어요")
```

```python
with open("study.txt", "r", encoding="utf-8") as study_file:
    print(study_file.read())
```

with 를 사용하면 파일을 읽고 쓰는 코드도 간결해지며, 매번 close() 함수를 호출해야 하는 부담도 줄어들기 때문에 보다 수월하게 파일 관련 작업을 할 수 있다.

# 9. 클래스

## 9-1. 클래스

```python
# 마린 : 공격 유닛, 군인. 총을 쏠 수 있음
name = "마린" # 유닛의 이름
hp = 40 # 유닛의 체력
damage = 5 # 유닛의 공격력

print("{} 유닛이 생성되었습니다.".format(name))
print("체력 {0}, 공격력 {1}\n".format(hp, damage))

# 탱크 : 공격 유닛, 탱크. 포를 쏠 수 있는데, 일반 모드 / 시즈 모드
tank_name = "탱크"
tank_hp = 150
tank_damage = 35

print("{} 유닛이 생성되었습니다.".format(tank_name))
print("체력 {0}, 공격력 {1}\n".format(tank_hp, tank_damage))

# 탱크2 새로 추가
tank2_name = "탱크"
tank2_hp = 150
tank2_damage = 35

print("{} 유닛이 생성되었습니다.".format(tank2_name))
print("체력 {0}, 공격력 {1}\n".format(tank2_hp, tank2_damage))

# 공격 함수
def attack(name, location, damage):
	print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]".format(name, location, damage))

attack(name, "1시" , damage) # 마린 공격 명령
attack(tank_name, "1시" , tank_damage) # 탱크 공격 명령
```

실제 게임에서는 서로 다른 종류의 유닛들이 최소 수십에서 많게는 수백개가 존재한다. 유닛마다 이렇게 서로 다른 정보(이름, 체력, 공격력 등) 를 관리하기에는 무리일 것이다.

이 때 필요한 것이 바로 `클래스`. 클래스는 보통 붕어빵 기계의 틀에 비유를 하는데, 붕어빵을 만들 때 틀에다가 재료를 넣고 불에 구우면 똑같은 모양의 붕어빵을 만들 수 있다. 틀은 하나인데 붕어빵은 계속해서 만들 수 있는 것! 클래스도 이러한 하나의 틀이라고 생각하시면 되는데 보통 **서로 연관이 있는 변수와 함수의 집합**으로 이루어진다.

기본적인 클래스

- class 뒤에 클래스 이름을 정의하고 콜론(:)을 적는다.
- 그 다음줄부터는 들여쓰기를 하고 필요한 메소드를 정의한다.
- 클래스 내에서 정의되는 함수를 `메소드` 라고 하는데, 앞에서 배운 함수와 거의 동일하다.
- 다만 첫 번째 전달값 위치에는 **self** 라는 것이 적힌다는 것을 주의할 것.
- 메소드 내의 각 실행명령문들은 또 한 번 들여쓰기를 통해서 정의한다.

```python
class 클래스명:
	def 메소드1(self, 전달값1, 전달값2, ...):
		실행 명령문1
		실행 명령문2
		...
	def 메소드2(self, 전달값1, 전달값2, ...):
		실행 명령문1
		실행 명령문2
		...
```

### 예제

Unit 이라는 이름으로 클래스를 정의하고 메소드를 하나 만드는데 이름은 **init** (언더바를 앞뒤로 각각 2개씩 적어주세요) 으로 한다. 그리고 처음에는 일단 self 를 적고 뒤에는 이름, 체력, 데미지에 해당하는 전달값들을 적는다. 메소드 내에서는 다음과 같은 형태로 변수를 정의할 수 있다.

self.변수명 = 값

이렇게 정의된 변수를 `멤버변수` 라고 하는데, **클래스 내에서 사용할 수 있는 변수** 정도로 이해하면 된다.

```python
class Unit:
	def __init__(self, name, hp, damage):
			self.name = name # 멤버변수 name에 전달값 name wjwkd
			self.hp = hp
			self.damage = damage
			print("{0} 유닛이 생성되었습니다.".format(self.name))
			print("체력 {0}, 공격력{1}".format(self.hp, self.damage))
```

그런데 클래스도 함수와 마찬가지로 정의만 해서는 아무 동작을 하지 않는다. 클래스 밖에서 유닛을 직접 만들어보자. 이 때 **클래스를 통해서 만들어지는 것**을 `객체(Object)`라고 표현하며, 이 객체는 클래스의 `인스턴스(Instance)`가 된다.

```python
marine1 = Unit("마린", 40, 5) # 마린1 생성. 전달값으로 name, hp, damage 를 전달
marine2 = Unit("마린", 40, 5) # 마린2 생성
tank = Unit("탱크", 150, 35) # 탱크 생성
```

Unit 클래스를 통해 만들어진 마린과 탱크를 `객체`라고 하며, 이 때 "마린과 탱크는 Unit 클래스의 `인스턴스`다" 라고 한다.

클래스를 통해 객체를 생성할 때는 아래와 같은 형식으로 한다.

변수명 = 클래스명(전달값1, 전달값2, ...) # 전달값은 클래스의 **init**() 에 정의된 부분 중 self 를 제외한 값

`클래스` : 서로 관련이 있는 변수(멤버변수)와 함수(메소드)들의 집합

클래스 내에는 여러 개의 메소드를 정의할 수 있는데 

- 각 메소드의 첫 번째 전달값 위치에는 **self** 를 적어준다.
- **init**() 메소드를 통해 기본적으로 **필요한 전달값들을 전달받고**,
- **self.** 을 통해 클래스의 **멤버 변수를 정의**한다.

## 9-2. __init__

클래스에는 **init**() 메소드가 있다. 이를 `생성자(Constructor)` 라고 부르는데요, 사용자가 따로 호출하지 않아도 클래스 **객체를 생성할 때 자동으로 호출이 되는 부분**이다. **객체를 생성할 때는 이 생성자의 전달값에 해당하는 갯수만큼 값을 던져줘야 한다.** (단, self 부분은 제외)

## 9-3. 멤버변수

`멤버변수` :클래스 내에서 정의된 변수를 의미하며 self. 와 함께 사용할 수 있다.

### 객체를 통해 접근하여 멤버변수 정보 출력하기

클래스 생성자나 메소드가 아닌 곳에서 멤버변수 정보를 출력해보자. 클래스 내에서는 self. 과 같이 멤버변수에 접근할 수 있었는데 객체를 통해 접근할 때에는 **객체 이름 뒤에 점(.) 을 찍고 멤버변수 이름을 적으면 된다.**

```python
# 레이스 : 공중 유닛, 비행기. 클로킹 (상대방에게 보이지 않음)
wraith1 = Unit("레이스", 80, 5) # 체력 80, 공격력 5
print("유닛 이름 : {0}, 공격력 : {1}".format(wraith1.name, wraith1.damage)) # 멤버변수 접근
```

객체 이름이 wraith1 이므로 이 객체가 가지는 멤버변수는 wraith1.name, wraith1.damage 와 같이 접근하여 값을 출력한다.

### 클래스 외부에서 멤버 변수 정의하기

```python
# 마인드 컨트롤 : 상대방 유닛을 내 것으로 만드는 것 (빼앗음)
wraith2 = Unit("빼앗은 레이스", 80, 5)
wraith2.cloaking = True # 빼앗은 레이스만을 위한 특별한 멤버변수 정의

if wraith2.cloaking == True: # 클로킹 상태라면?
    print("{0}는 현재 클로킹 상태입니다.".format(wraith2.name))

# 에러 발생
# if wraith1.cloaking == True: # 우리가 만든 레이스 클로킹 여부
#     print("{0}는 현재 클로킹 상태입니다.".format(wraith1.name))
```

Unit 클래스에는 처음과 변함 없이 name, hp, damage 라는 3개의 멤버변수가 있고 cloaking은 없다. 하지만 wraith2 는 클래스 외부에서 직접 cloaking 이라는 멤버 변수를 정의하였고, 이는 모든 Unit 객체가 아닌 오직 wraith2 에만 해당된다.

wraith1의 멤버변수: name, hp, damage

wraith2의 멤버변수: name, hp, damage, cloaking

이와 같이 클래스로부터 객체를 만든 다음 그 객체만을 위한 멤버 변수 정의가 필요한 경우에는 클래스 외부에서 별도로 정의할 수 있으며, 이 때 이 객체를 제외한 다른 객체들은 새로 정의된 멤버 변수를 알지 못하며 사용할 수도 없다. 오직 이 객체만을 위한 멤버변수가 되는 것이다.

## 9-4. 메소드(method)

클래스에는 여러 개의 메소드를 정의할 수 있는데 일반 함수와 다른 점이라면

- 메소드는 전달값을 정의하는 부분 처음에 self를 적어준다는 점
- 메소드 내에서 self. 을 통해 클래스 멤버변수에 접근 가능하다는 점

### 예제

```python
class AttackUnit: # 공격 유닛
		def __init__(self, name, hp, damage):
				self.name = name
				self.hp = hp
				self.damage = damage
		def attack(self, location): # 전달 받은 방향으로 공격
				print("{0} : {1} 방향으로 적군을 공격합니다. [공격력 {2}]" \
							.format(self.name, location, self.damage)) # 공간이 좁아서 2줄에 걸쳐 출력
		def damaged(self, damage): # damage 만큼 유닛 피해
				print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage)) # 데미지 정보 출력
				self.hp -= damage # 유닛의 체력에서 전달받은 damage 만큼 감소
				print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp)) # 남은 체력 출력
				if self.hp <= 0: # 남은 체력이 0 이하이면?
						print("{0} : 파괴되었습니다.".format(self.name)) # 유닛 파괴 처리
```

이 때 유닛 이름과 공격력은 이미 클래스 객체의 멤버 변수로 정의되어 있기 때문에 자기 자신을 의미하는 self. 을 쓰고, **공격 방향은** 명령을 받을 때마다 달라질 수 있으므로 멤버 변수가 아닌 전달값을 사용하기 위해 **self. 없이 쓴다는 점 주의**해야 한다.

하나의 문장이 너무 길어서 한 줄에 표현하기 어렵거나 보기 좋게 두 줄 이상으로 나누고자 할 때는 `문장 끝에 역슬래시(\)` 를 넣음으로써 다음 줄에서 계속하여 문장을 이어갈 수 있다.

```python
# 파이어뱃 : 공격 유닛, 화염방사기.
firebat1 = AttackUnit("파이어뱃", 50, 16) # 체력 50, 공격력 16
firebat1.attack("5시") # 5시 방향으로 공격 명령

# 공격 2번 받는다고 가정
firebat1.damaged(25) # 남은 체력 25
firebat1.damaged(25) # 남은 체력 0
```

self 는 자기 자신을 의미한다. 생성자 또는 메소드에서 self 를 전달받는 것은 결국 자기 자신을 받는다는 의미이며 메소드 내에서 self. 를 쓰는 것은 자기 자신의 멤버 변수 또는 메소드에 접근하겠다는 의미가 된다.
firebat1 은 AttackUnit 클래스의 인스턴스이며 코드상에서 객체를 생성할 때는 name, hp, damage 정보만 전달하지만 자동으로 호출되는 __init__() 생성자의 처음 위치에 있는 self 에 자기 자신을 전달하는 것과 같다.
그래서 생성자 내에서 self.name = name 이라고 하는 것은 마치 firebat1.name = name 과 같은 동작이 되는 것이다.

머리가 아파지려고 한다면, 그냥 클래스 메소드의 처음 위치에는 self 를 적어야 하며 클래스 내에서는 self.name 또는 self.attack(...) 과 같이 self. 과 함께 멤버 변수 또는 메소드 이름을 적어서 접근할 수 있다는 것만 기억하면 된다.

## 9-5. 상속

### 예제

AttackUnit 클래스에 공격력을 의미하는 damage 멤버 변수가 있으므로 Unit 클래스는 공격 가능 여부와 상관없이 일반적인 유닛을 위한 클래스로 수정하자.

```python
# 일반 유닛
class Unit:
    def __init__(self, name, hp):
        self.name = name
        self.hp = hp

# 공격 유닛
class AttackUnit:
    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    def attack(self, location):
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage))

    def damaged(self, damage):
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage))
        self.hp -= damage
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp))
        if self.hp <= 0:
            print("{0} : 파괴되었습니다.".format(self.name))
```

Unit 클래스와 AttackUnit 클래스의 **init**() 생성자만 놓고 비교해보니 겹치는 부분이 있다. 일반 유닛도 name, hp 를 가지고 공격 유닛도 name, hp 를 가진다. 만약 Unit 의 성격에 따라 공격 유닛, 공중 유닛, 공중 공격 유닛 등 수많은 클래스로 확장이 된다면 매 클래스마다 name, hp 를 일일이 적어주어야 할 것이다.

다행히 클래스에는 `상속`이라는 개념이 있어서 **공통되는 부분은 코드를 중복으로 적지 않고도 재사용을 할 수 있다.** AttackUnit 클래스는 Unit 클래스의 name, hp 멤버변수를 포함하면서 추가로 damage 멤버변수를 정의하고 있으므로 Unit 클래스로부터 상속을 받으면 Unit 클래스의 name, hp 를 그대로 사용할 수 있게 된다.

클래스를 상속받을 때는 클래스 이름 뒤에 괄호를 적고 상속 받을 클래스 이름을 명시해주면 된다. 그리고 이 때 두 클래스는 `자식클래스`와 `부모클래스`라고 표현한다. 

class 자식클래스(상속받을 부모클래스):

그리고 코드를 재사용하기 위해 AttackUnit 클래스의 __init__() 생성자에서 name, hp 멤버변수를 정의하는 부분은 다음과 같이 부모 클래스의 __init__() 생성자를 호출하는 방식으로 코드를 간소화할 수 있다. 이 때도 self 를 넘겨주는 것은 잊지말 것.

```python
# 공격 유닛
class AttackUnit(Unit): # Unit 클래스를 상속
    def __init__(self, name, hp, damage):
        Unit.__init__(self, name, hp) # 부모 클래스의 생성자 호출
        self.damage = damage
        
    ... # 메소드 생략
```

이렇게 하면 AttackUnit 클래스는 Unit 클래스의 모든 멤버변수와 메소드를 그대로 이용할 수 있으며 거기에 AttackUnit 만을 위한 멤버변수와 메소드를 추가로 확장할 수 있게 된다.

서로 관련 있는 클래스들은 이와 같이 공통적인 부분은 부모 클래스로 정의하고 자식 클래스에서는 필요한 부분을 확장하여 사용하면 불필요한 코드의 중복을 방지할 수 있고 변경이 필요한 경우에도 작업을 최소화할 수 있다.

## 9-6. 다중상속

### 예제

```python
# 날 수 있는 기능을 가진 클래스
class Flyable:
    def __init__(self, flying_speed): # 공중 이동 속도
        self.flying_speed = flying_speed

    def fly(self, name, location): # 유닛 이름, 이동 방향
        print("{0} : {1} 방향으로 날아갑니다. [속도 {2}]"\
            .format(name, location, self.flying_speed))
```

그럼 공중 공격 유닛을 위한 새로운 클래스를 만들어보자. 이름은 FlyableAttackUnit 으로 한다. 이번에는 AttackUnit 과 Flyable 클래스를 함께 상속받도록 한다. 

이렇게 **2개 이상의 클래스를 상속받는 것**을 `다중 상속`이라고 표현하며 형태는 다음과 같이 콤마(,)로 구분하여 부모 클래스들의 이름을 작성하면 된다.

class 자식클래스(부모클래스1, 부모클래스2, ...):

```python
# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed): # 이름, 체력, 공격력, 공중 이동 속도
        AttackUnit.__init__(self, name, hp, damage) # 이름, 체력, 공격력
        Flyable.__init__(self, flying_speed) # 공중 이동 속도

# 발키리 : 공중 공격 유닛, 한번에 14발 미사일 발사.
valkyrie = FlyableAttackUnit("발키리", 200, 6, 5) # 이름, 체력, 공격력, 공중 이동 속도
valkyrie.fly(valkyrie.name, "3시") # 3시 방향으로 발키리를 이동
```

## 9-7. 메소드 오버라이딩

`메소드 오버라이딩(method overriding)` :상속 관계에 있는 클래스들 사이에서 부모 클래스에 정의된 메소드를 그대로 사용하지 않고 자식 클래스에서 같은 이름으로 메소드를 새롭게 정의하여 사용하도록 하는 것.

### 예제

스타크래프트 유닛들은 플레이어가 지정한 위치나 방향으로 이동을 할 수 있는데 유닛마다 서로 다른 이동 속도를 가진다. 빠른 유닛도 있고 느린 유닛도 있다. 참고로 공중 유닛을 위한 Flyable 클래스에는 이미 공중 이동 속도를 의미하는 flying_speed 가 정의되어 있다. 그래서 이번에는 지상 유닛을 위한 이동 속도를 의미하는 speed 를 Unit 클래스에 추가해보자. 그리고 이동을 위한 move() 메소드도 새롭게 정의하고 구분을 위해 [지상 유닛 이동] 이라는 문구와 함께 어떤 유닛이 몇 시 방향으로 이동하는지를 출력한다.

```python
# 일반 유닛
class Unit:
    def __init__(self, name, hp, speed): # speed 추가
        self.name = name
        self.hp = hp
        self.speed = speed # 지상 이동 속도

    def move(self, location): # 이동 함수 정의
        print("[지상 유닛 이동]")
        print("{0} : {1} 방향으로 이동합니다. [속도 {2}]"\
            .format(self.name, location, self.speed))
```

이렇게 변경하고 나면 Unit 클래스를 상속받고 있는 클래스에 영향을 끼치게 된다. speed 가 새롭게 추가되었으니 __init__() 메소드를 사용하는 부분도 변경을 해줘야 한다.

먼저 공격 유닛인 AttackUnit 클래스에 speed 를 추가하자.

```python

# 공격 유닛
class AttackUnit(Unit):
    def __init__(self, name, hp, speed, damage): # speed 추가
        Unit.__init__(self, name, hp, speed) # speed 추가
        self.damage = damage
        
    ... # 메소드 생략

# 벌쳐 : 지상 유닛, 기동성이 좋음
vulture = AttackUnit("벌쳐", 80, 10, 20) # 지상 speed 10
```

다음으로는 AttackUnit 클래스를 상속받는 공중 공격 유닛인 FlyableAttackUnit 클래스도 수정을 하자. 공중 공격 유닛의 경우 공중 이동 속도인 flying_speed 가 이미 정의되어 있으며 지상으로는 이동하지 못하기 때문에 지상 이동 속도는 그냥 0 으로 설정을 해준다.

```python
# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed):
        AttackUnit.__init__(self, name, hp, 0, damage) # 지상 speed 0
        Flyable.__init__(self, flying_speed)

# 배틀크루저 : 공중 유닛, 체력도 굉장히 좋음, 공격력도 좋음
battlecruiser = FlyableAttackUnit("배틀크루저", 500, 25, 3)
```

```python
vulture.move("11시")
battlecruiser.fly(battlecruiser.name, "9시")
```

그런데 스타크래프트에는 굉장히 많은 지상 유닛과 공중 유닛이 있는데 이들을 이동시킬 때마다 지상 유닛인지 공중 유닛인지를 구분하여 move() 와 fly() 를 적기에는 너무 번거롭다. 그리고 fly() 를 이용할때는 유닛의 이름정보까지 전달해야하는 불편함도 있다.

→ 이런 경우에 `메소드 오버라이딩` 을 이용할 수 있다.

FlyableAttackUnit 클래스에서 상속 받고 있는 부모 클래스는 AttackUnit 과 Flyable 이다. AttackUnit 클래스는 Unit 클래스를 상속 받고 있으므로 결국 FlyableAttackUnit 클래스에서도 Unit 클래스의 모든 내용을 그대로 사용할 수 있다.

여기서는 Unit 클래스에 정의된 move() 메소드를 FlyableAttackUnit 클래스 내에서 `오버라이딩` 해보자. 메소드 오버라이딩은 **부모 클래스에 정의된 메소드를 그대로 자식 클래스에서 동일한 이름과 동일한 전달값으로 하여 정의하면 된다.** 대신 메소드 동작만 원하는대로 변경하면 된다. 공중 공격 유닛의 이동이므로 [공중 유닛 이동] 이라는 문구를 출력하고 실제 이동은 공중으로 날아다녀야 하므로 또다른 부모 클래스인 Flyable 에 정의된 fly() 메소드를 호출하는 것으로 한다. 이 때 유닛 이름과 이동할 위치 정보를 함께 전달한다.

```python
# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed):
        AttackUnit.__init__(self, name, hp, 0, damage)
        Flyable.__init__(self, flying_speed)

    def move(self, location): # Unit 클래스의 move() 메소드를 새롭게 정의 (오버라이딩)
        print("[공중 유닛 이동]")
        self.fly(self.name, location)
```

이제 다시 한 번 유닛들을 이동시켜볼텐데 이번에는 지상 공중 구분 없이 모두 move() 로만 이동해보자. 배틀크루저의 경우 유닛 이름을 전달해야 하는 번거로움을 줄일 수 있다.

```python
vulture.move("11시")
# battlecruiser.fly(battlecruiser.name, "9시")
battlecruiser.move("9시") # 오버라이딩된 move() 호출
```

다음 도표를 보면 상속 관계는 변함이 없지만 Unit 클래스에 move() 를 정의함으로써 Unit 클래스 객체들은 모두 move() 를 통해 지상 이동을 할 수 있다. 하지만 공중 공격 유닛인 FlyableAttackUnit 은 지상 이동이 아닌 공중 이동을 해야 하므로 Flyable 클래스의 fly() 를 쓰고 있었는데 유닛이 많아지면 관리가 어려우므로 move() 를 재정의하여 메소드 내에서 fly() 를 호출하도록 했다. 이렇게 하면 유닛별로 같은 move() 를 호출하더라도 AttackUnit 을 통해 만들어진 유닛은 부모 클래스인 Unit 의 move() 를, FlyableAttackUnit 을 통해 만들어진 유닛은 오버라이딩을 통해 새롭게 정의된 FlyableAttackUnit 의 move() 를 호출하게 된다.

![overriding.png](/img/overriding.png)

클래스 간 상속 관계

## 9-8. pass

스타크래프트에는 유닛을 뽑는 수에 제한이 있다. 처음 게임을 시작할 때 8 만큼의 인구 수에 해당하는 유닛을 만들 수 있는데, 그 수를 초과하게 되면 더 이상 유닛을 뽑지 못하게 된다. 이 때 더 많은 유닛을 계속하여 뽑기 위해서는 각 종족별로 무언가를 더 해줘야 하는데 테란의 경우 서플라이 디폿이라는 건물을 지으면 된다. 서플라이 디폿 건물이 하나씩 늘어날 때마다 인구 수 8 만큼 유닛을 더 만들 수 있게 되는 것이다.

이번에는 건물을 위한 클래스를 하나 만들어 보자. 건물도 일반 유닛처럼 이름과 체력이 있는데 적군으로부터 공격을 받으면 파괴될 수 있다. Unit 클래스에 공통 속성이 있으니 이를 상속 받아서 만들도록 하자. 건물을 지을 때는 어느 위치에 지을지 플레이어가 정해야 하는데 이들을 모두 포함하여 name, hp, location 이라고 하자. 그런데 건물은 **클래스를 정의하기는 하는데 init() 생성자의 세부 내용은 일단은 그냥 내버려 두고** 다른 작업을 먼저 하고 나서 나중에 코드를 완성한다고 가정한다. 이럴 때 파이썬에서는 `pass` 를 쓸 수 있다.

```python
# 건물
class BuildingUnit(Unit):
    def __init__(self, name, hp, location):
        pass

# 서플라이 디폿 : 건물, 1개 건물 = 8 유닛.
supply_depot = BuildingUnit("서플라이 디폿", 500, "7시") # 체력 500, 생성 위치 7시
```

이렇게만 한 상태에서 서플라이 디폿 객체를 만들고 실행을 해보면 에러 없이 잘 실행되는 것을 볼 수 있다. 여기서 `pass` 는 **아무것도 하지 않고 일단은 그냥 넘어간다는 의미로 사용**됩니다. 즉, **init() 생성자는 실제로는 완성되지 않았지만 마치 완성된 것처럼 보여질 수 있다.**

pass 는 다른 곳에서도 사용이 가능하다. 위 코드에 이어서 함수를 2개 만들어보자. 게임 시작을 알리는 game_start() 함수와 게임 종료를 알리는 game_over() 함수이다. game_start() 에서는 print() 를 통해 문구를 출력하는데 game_over() 에서는 그냥 pass 로만 적어둔다.

```python
def game_start():
    print("[알림] 새로운 게임을 시작합니다.")

def game_over():
    pass

game_start()
game_over()
```

```python
# 실행 결과
[알림] 새로운 게임을 시작합니다.
```

game_start() 함수에서는 정의된 동작을 수행하고 game_over() 함수에서는 pass 를 통해 그냥 넘어가게 된다. 함수 뿐 아니라 if, for, while 등에서도 `pass` **를 사용하여 당장은 세부 동작을 정의하지 않은 채로 뒀다가 나중에 다시 코드를 완성하도록 할 수 있다.**

## 9-9. super

우리가 누군가의 부모님을 칭할 때 이름을 직접 부르는 경우는 많지 않다. 예를 들어서 주말에 친구들과 놀러가기로 했을 때 "우리 놀러 가는 거 부모님께 허락 받았어?" 라고 물어보지, "OOO님 허락 받았어?" 라고는 하지 않는다.

클래스에서도 이와 같이 **부모 클래스의 이름을 직접 적지 않고도 부모 클래스에 접근하는 방법**이 있습니다. 바로 `super()` 라는 것이다. 앞의 코드는 다음과 같이 함으로써 동일한 동작을 수행하게 됩니다. 단, s**uper() 를 사용할 때는 self 를 제외한다**는 점을 주의해야 한다.

```python
class BuildingUnit(Unit):
    def __init__(self, name, hp, location):
        super().__init__(name, hp, 0) # 부모 클래스 접근. self 없이 사용
        self.location = location
```

### 다중상속인 경우

```python
class Unit:
    def __init__(self):
        print("Unit 생성자")

class Flyable:
    def __init__(self):
        print("Flyable 생성자")

class FlyableUnit(Unit, Flyable):
    def __init__(self):
        super().__init__()

# 드랍쉽
dropship = FlyableUnit()
```

```python
# 실행 결과
Unit 생성자
```

부모 클래스는 Unit과 Flyable인데 super()를 통해 생성자를 호출햇을 때 Unit 클래스의 생성자가 호출된 것을 알 수 있다.

```python
# class FlyableUnit(Unit, Flyable):
class FlyableUnit(Flyable, Unit): # 순서 변경
    def __init__(self):
        super().__init__()
```

```python
# 실행 결과
Flyable 생성자
```

즉, **다중 상속을 받은 클래스에서 super() 를 통해 부모 클래스로 접근을 할 때는 순서상 가장 먼저 상속받은 클래스로 접근을 하게 된다.** 그러므로 다중 상속을 할 때 모든 부모 클래스의 생성자를 호출하려면 다음과 같이 명시적으로 각 부모 클래스의 이름을 통해서 접근해야 한다.

```python
class FlyableUnit(Flyable, Unit):
    def __init__(self):
        # super().__init__()
        Unit.__init__(self) # Unit 클래스 생성자 호출
        Flyable.__init__(self) # Flyable 클래스 생성자 호출
```

```python
# 실행 결과
Unit 생성자
Flyable 생성자
```

## 9-10. 스타크래프트 프로젝트 전반전

탱크는 특수 기술로 시즈(siege)모드가 있는데 이 기술을 사용하면 지상에 탱크를 고정시켜서 무려 2배에 달하는 공격력과 더 넓은 사정거리로 공격이 가능하다. 다만, 이 기술은 처음부터 바로 사용할 수는 없고 업그레이드를 통한 시즈모드 개발을 완료해야만 사용 가능하다.

테란 본진에서 시즈모드를 개발하게 되면 그 시점부터는 모든 탱크가 시즈모드로 전환할 수 있게 됩니다. 이미 만들어진 탱크도, 앞으로 만들어질 탱크도 모두 포함해서 말이다. 이렇게 **어떤 클래스로부터 만들어진 객체에 일괄적으로 뭔가를 적용하려면** 멤버변수가 아닌 `클래스 변수`로 선언할 수 있다. 코드에서는 siege_developed 라는 이름으로 클래스 변수를 선언하는데 선언 위치가 어디인지를 잘 확인하자.

```python
# 탱크
class Tank(AttackUnit):
    # 시즈모드 : 탱크를 지상에 고정시켜, 더 높은 파워로 공격 가능. 이동 불가.
    siege_developed = False # 시즈모드 개발여부
```

클래스 변수는 클래스 이름과 함께 어디서든지 사용 가능합니다. `Tank.siege_developed` 라고 하면 **탱크 클래스 변수의 값에 직접 접근하여 시즈모드 개발이 완료되었는지를 확인할 수 있다.** `멤버변수`가 각 클래스 객체마다 다른 값을 가진다면 `클래스 변수`는 **모든 객체가 동일한 값을 가진다**는 점이 다르다.

시즈모드 개발이 완료되었다고 해서 모든 탱크가 시즈모드를 항상 해야하는 것은 아니므로 시즈모드 여부를 확인하기 위해 siege_mode 라는 멤버변수를 정의한다. 처음에는 일반모드일 테니 시즈모드를 해제 상태로, 즉 False 로 두자.

```python
# 탱크
class Tank(AttackUnit):
    ... # 생략

    def __init__(self):
        AttackUnit.__init__(self, "탱크", 150, 1, 35) # 이름, 체력, 이동속도, 공격력
        self.siege_mode = False # 시즈모드 (해제 상태)
```

그리고 시즈모드와 일반모드를 전환하기 위한 set_siege_mode() 메소드를 정의한다. 이 메소드가 호출되면 현재 시즈모드 개발이 완료되었는지 여부를 먼저 확인하여 완료되지 않은 경우는 바로 메소드를 탈출하도록 한다. 완료된 상태라면 지금 이 탱크 객체의 시즈모드 설정 여부를 확인하여 일반모드인 경우는 시즈모드로, 시즈모드인 경우는 일반모드로 전환한다. 그 과정에서 공격력을 증가하거나 감소시켜주고 필요한 문구를 출력한다. 마지막으로 멤버변수인 siege_mode 의 값을 True 또는 False 로 변경하여 시즈모드 설정 / 해제 여부를 저장한다.

```python
# 탱크
class Tank(AttackUnit):
    ... # 생략
    
    # 시즈모드
    def set_siege_mode(self):
        if Tank.siege_developed == False: # 시즈모드가 개발되지 않은 경우 메소드 탈출
            return

        # 현재 시즈모드가 아닐 때
        if self.siege_mode == False:
            print("{0} : 시즈모드로 전환합니다.".format(self.name))
            self.damage *= 2 # 공격력 2배로 증가
            self.siege_mode = True # 시즈 모드 설정
        # 현재 시즈모드일 때
        else:
            print("{0} : 시즈모드를 해제합니다.".format(self.name))
            self.damage /= 2 # 공격력 절반으로 감소
            self.siege_mode = False # 시즈 모드 해제
```

## 9-11. 스타크래프트 프로젝트 후반전

```python
... # 클래스 생략

# 게임 시작
def game_start():
    print("[알림] 새로운 게임을 시작합니다.")

# 게임 종료
def game_over():
    print("Player : gg") # good game
    print("[Player] 님이 게임에서 퇴장하셨습니다.")
```

```python
# 게임 시작
game_start()

# 마린 3기 생성
m1 = Marine()
m2 = Marine()
m3 = Marine()

# 탱크 2기 생성
t1 = Tank()
t2 = Tank()

# 레이스 1기 생성
w1 = Wraith()
```

총 6기의 유닛이 만들어졌는데 어딘가로 이동을 하거나 공격을 할 때 한꺼번에 처리하도록 하기 위해 이들을 리스트로 관리하자.

```python
# 유닛 일괄 관리 (생성된 모든 유닛 append)
attack_units = []
attack_units.append(m1)
attack_units.append(m2)
attack_units.append(m3)
attack_units.append(t1)
attack_units.append(t1)
attack_units.append(w1)
```

```python
# 전군 이동
for unit in attack_units:
    unit.move("1시")
```

모든 유닛들은 Unit 클래스를 상속받았으므로 Unit 클래스의 move() 메소드를 사용할 수 있으며, 또한 모든 유닛들을 리스트로 관리하고 있기 때문에 반복문을 이용하여 수월하게 이동할 수 있다.

```python
# 탱크 시즈모드 개발
Tank.siege_developed = True
print("[알림] 탱크 시즈 모드 개발이 완료되었습니다.")
```

적군으로 이동을 하는 와중에 탱크의 시즈 모드 개발이 완료되었다고 가정하자. Tank 클래스에 선언된 클래스 변수 siege_developed 는 Tank.siege_developed 를 통해 접근할 수 있으며 값을 True 로 설정해준다.

전쟁 직전에 각 유닛들이 가진 특수 기술을 사용하여 보다 강력한 공격을 할 텐데, 마린은 스팀팩, 탱크는 시즈모드, 레이스는 클로킹모드를 각각 사용해야 한다. 리스트로 관리되는 유닛들은 서로 다른 기술을 사용해야 하는데 이들을 구분하기 위해서 isinstance() 를 활용할 수 있다.

instance(객체, 클래스)

이렇게 하면 **객체가 특정 클래스의 인스턴스인지 여부를 확인할 수 있다.** 예제에서는 각 유닛 객체들이 Marine 클래스의 인스턴스인지, Tank 또는 Wraith 클래스의 인스턴스인지 여부를 확인하여 각 유닛에 맞는 특수 기술을 사용하도록 한다.

```python
# 공격 모드 준비 (마린 : 스팀팩, 탱크 : 시즈모드, 레이스 : 클로킹)
for unit in attack_units:
    if isinstance(unit, Marine): # Marine 의 인스턴스이면 스팀팩
        unit.stimpack()
    elif isinstance(unit, Tank): # Tank 의 인스턴스이면 시즈모드
        unit.set_siege_mode()
    elif isinstance(unit, Wraith): # Wraith 의 인스턴스이면 클로킹
        unit.cloaking()
```

![class_inheritance.png](/img/class_inheritance.png)

```python
from random import *

# 일반 유닛
class Unit:
    def __init__(self, name, hp, speed):
        self.name = name
        self.hp = hp
        self.speed = speed
        print("{0} 유닛이 생성되었습니다.".format(name))

    def move(self, location):
        print("{0} : {1} 방향으로 이동합니다. [속도 {2}]"\
            .format(self.name, location, self.speed))

    def damaged(self, damage):
        print("{0} : {1} 데미지를 입었습니다.".format(self.name, damage))
        self.hp -= damage
        print("{0} : 현재 체력은 {1} 입니다.".format(self.name, self.hp))
        if self.hp <= 0:
            print("{0} : 파괴되었습니다.".format(self.name))

# 공격 유닛
class AttackUnit(Unit):
    def __init__(self, name, hp, speed, damage):
        Unit.__init__(self, name, hp, speed)
        self.damage = damage

    def attack(self, location):
        print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]" \
            .format(self.name, location, self.damage))

# 마린
class Marine(AttackUnit):
    def __init__(self):
        AttackUnit.__init__(self, "마린", 40, 1, 5) # 이름, 체력, 이동속도, 공격력

    # 스팀팩 : 일정 시간 동안 이동 및 공격 속도를 증가, 체력 10 감소
    def stimpack(self):
        if self.hp > 10:
            self.hp -= 10
            print("{0} : 스팀팩을 사용합니다. (HP 10 감소)".format(self.name))
        else:
            print("{0} : 체력이 부족하여 스팀팩을 사용하지 않습니다".format(self.name))

# 탱크
class Tank(AttackUnit):
    # 시즈모드 : 탱크를 지상에 고정시켜, 더 높은 파워로 공격 가능. 이동 불가.
    siege_developed = False # 시즈모드 개발여부 (클래스 변수)

    def __init__(self):
        AttackUnit.__init__(self, "탱크", 150, 1, 35) # 이름, 체력, 이동속도, 공격력
        self.siege_mode = False # 시즈모드 (해제 상태)
    
    # 시즈모드
    def set_siege_mode(self):
        if Tank.siege_developed == False: # 시즈모드가 개발되지 않은 경우 메소드 탈출
            return

        # 현재 시즈모드가 아닐 때
        if self.siege_mode == False:
            print("{0} : 시즈모드로 전환합니다.".format(self.name))
            self.damage *= 2 # 공격력 2배로 증가
            self.siege_mode = True # 시즈 모드 설정
        # 현재 시즈모드일 때
        else:
            print("{0} : 시즈모드를 해제합니다.".format(self.name))
            self.damage /= 2 # 공격력 절반으로 감소
            self.siege_mode = False # 시즈 모드 해제

# 날 수 있는 기능을 가진 클래스
class Flyable:
    def __init__(self, flying_speed):
        self.flying_speed = flying_speed

    def fly(self, name, location):
        print("{0} : {1} 방향으로 날아갑니다. [속도 {2}]"\
            .format(name, location, self.flying_speed))

# 공중 공격 유닛
class FlyableAttackUnit(AttackUnit, Flyable):
    def __init__(self, name, hp, damage, flying_speed):
        AttackUnit.__init__(self, name, hp, 0, damage)
        Flyable.__init__(self, flying_speed)

    def move(self, location):
        self.fly(self.name, location)

# 레이스
class Wraith(FlyableAttackUnit):
    def __init__(self):
        FlyableAttackUnit.__init__(self, "레이스", 80, 20, 5) # 체력, 공격력, 공중 이동 속도
        self.cloaked = False # 클로킹 모드 (해제 상태)

    # 클로킹 모드
    def cloaking(self):
        # 현재 클로킹 모드일 때
        if self.cloaked == True:
            print("{0} : 클로킹 모드 해제합니다.".format(self.name))
            self.cloaked = False
        # 현재 클로킹 모드가 아닐 때
        else:
            print("{0} : 클로킹 모드 설정합니다.".format(self.name))
            self.cloaked = True

# 게임 시작
def game_start():
    print("[알림] 새로운 게임을 시작합니다.")

# 게임 종료
def game_over():
    print("Player : gg") # good game
    print("[Player] 님이 게임에서 퇴장하셨습니다.")

# 실제 게임 진행
game_start()

# 마린 3기 생성
m1 = Marine()
m2 = Marine()
m3 = Marine()

# 탱크 2기 생성
t1 = Tank()
t2 = Tank()

# 레이스 1기 생성
w1 = Wraith()

# 유닛 일괄 관리 (생성된 모든 유닛 append)
attack_units = []
attack_units.append(m1)
attack_units.append(m2)
attack_units.append(m3)
attack_units.append(t1)
attack_units.append(t1)
attack_units.append(w1)

# 전군 이동
for unit in attack_units:
    unit.move("1시")

# 탱크 시즈모드 개발
Tank.siege_developed = True
print("[알림] 탱크 시즈 모드 개발이 완료되었습니다.")

# 공격 모드 준비 (마린 : 스팀팩, 탱크 : 시즈모드, 레이스 : 클로킹)
for unit in attack_units:
    if isinstance(unit, Marine): # Marine 의 인스턴스이면 스팀팩
        unit.stimpack()
    elif isinstance(unit, Tank): # Tank 의 인스턴스이면 시즈모드
        unit.set_siege_mode()
    elif isinstance(unit, Wraith): # Wraith 의 인스턴스이면 클로킹
        unit.cloaking()

# 전군 공격
for unit in attack_units:
    unit.attack("1시")

# 전군 피해
for unit in attack_units:
    unit.damaged(randint(5, 20)) # 공격은 랜덤으로 받음 (5 ~ 20)

# 게임 종료
game_over()
```
# 10. 예외처리

## 10-1. 예외처리

먼저 우리 실생활에서 겪을 수 있는 상황을 예로 들어보자.

1. 택배 기사님께서 배송중인 물건을 보니 주소가 아파트의 11층으로 되어 있는데 실제로는 10층까지만 있는 경우

2. 버스를 타고 단말기에 교통카드를 갖다댔는데 "잔액이 부족합니다" 라고 하는 경우

3. 컴퓨터에서 계산기 프로그램을 이용하려고 하는데 실수로 숫자 대신 문자를 입력 받은 경우

4. 어떤 홈페이지에 접속하려는데 주소를 잘못 적거나 사용자가 많아서 서버에 접속이 정상적으로 되지 않는 경우

이런 경우들처럼 **예상치 못한 어떤 실책이나 실수 또는 잘못된 무언가**를 `에러(error)` 라고 하며 **에러 상황을 처리하는 것**을 `예외(exception) 처리`라고 한다. 가령 첫 번째 경우라면 물건을 받으실 분의 전화번호로 연락을 하여 주소를 다시 한 번 확인하는 방향으로 처리할 수 있을 것이다.

에러에 대한 예외 처리는 다음과 같은 형태로 작성한다.

```
try:
    실행 명령문1
    실행 명령문2
    ...
except 에러 종류1:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
except 에러 종류2:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
```

### 예제

```python
print("나누기 전용 계산기입니다.")
num1 = int(input("첫 번째 숫자를 입력하세요 : "))
num2 = int(input("두 번째 숫자를 입력하세요 : "))
print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
```

만약 숫자가 아닌 문자를 입력하면 어떻게 될까?

```python
# 실행 결과
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 삼
Traceback (most recent call last):
  File "파일경로", line 3, in <module>
    num2 = int(input("두 번째 숫자를 입력하세요 : "))
ValueError: invalid literal for int() with base 10: '삼'
```

에러 메시지가 출력되면서 프로그램이 종료된다. 코드에서는 입력받은 값을 int()로 감싸서 정수형으로 변환을 해야하는데 "삼"은 정수로 변환을 할 수가 없는 문자라서 발생하는 에러다.

발생한 에러 메시지 중 마지막 문장을 보면 ValueError라는 에러 종류와 함께 자세한 메시지가 출력되고 있다.

ValueError 는 이름에서 유추할 수 있듯이 값이 잘못되어서 발생하는 에러인데 이에 대한 예외처리를 적용하도록 해보자. 

- 먼저 실행하려는 코드 위에 try: 를 적고, 하위 코드들은 모두 들여쓰기를 해준다.
- 그리고 밑에서 except 뒤에 어떤 에러에 대한 처리인지를 명시해준다.
- 여기서는 ValueError 에 대한 처리가 되며, 다음 줄부터 들여쓰기를 한 뒤 예외 처리 명령문을 적으면 된다.

이렇게 코드를 작성하면 try 와 except 사이에서 실행되는 명령문 중에서 ValueError 가 발생하는 경우, except ValueError: 부분의 코드가 실행되고 나서 프로그램은 계속하여 실행됩니다. 만약 아무 에러가 발생하지 않는다면 except 부분은 실행이 되지 않고 넘어가게 된다.

```python
try:
    print("나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요 : "))
    num2 = int(input("두 번째 숫자를 입력하세요 : "))
    print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
```

코드를 실행시키고 6과 3을 순서대로 입력하면 예외처리를 하기 전과 동일한 결과가 나오는 것을 알 수 있다.

```python
# 실행 결과
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 3
6 / 3 = 2
```

다시 한 번 실행시키고 6과 "삼" 이라고 입력하면?

```python
# 실행 결과
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 삼
에러! 잘못된 값을 입력하였습니다.
```

이번에는 알아보기 어려운 에러메시지 대신 `except ValueError:` 부분의 print() 문이 실행되는 것을 확인할 수 있다.

프로그램을 다시 한 번 실행시키고 6과 0을 입력해보자.

```python
# 실행 결과
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 0
Traceback (most recent call last):
  File "파일경로", line 5, in <module>
    print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
ZeroDivisionError: division by zero
```

새로운 에러인 ZeroDivisionError 가 나오면서 메시지가 출력된다. 모든 수는 0으로 나눌 수 없는데 두 번째 값으로 0을 넣어서 발생하는 오류다.

이렇게 서로 다른 종류의 에러에 대해 각각 처리하려면 except 구문을 추가하여 작성하면 된다. 앞의 코드에 추가하여 ZeroDivisionError 에 대한 예외처리를 추가하는데 이번에는 에러 뒤에 as 구문을 이용하여 err이라는 이름을 통해 에러 메시지를 직접 출력해보자.

```python
try:
    print("나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요 : "))
    num2 = int(input("두 번째 숫자를 입력하세요 : "))
    print("{0} / {1} = {2}".format(num1, num2, int(num1/num2)))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)
```

프로그램을 실행하고 6과 0을 입력해보면 다음과 같이 결과가 출력된다.

```python
# 실행 결과
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 0
division by zero
```

사용자로부터 값을 입력받는 과정에서 ZeroDivisionError 가 발생했고 예외처리를 통해서 except ZeroDivisionError 부분이 실행되었는데 우리가 직접 정의하지 않은 division by zero 라는 문구가 출력되었다.

이는 예외처리 전에 발생한 에러 메시지 중 ZeroDivisionError: 뒤에 나오는 메시지가 그대로 출력된 것이다.

ZeroDivisionError: division by zero

이와 같이 에러의 종류에 따라 쉽게 알아볼 수 있는 메시지가 제공되는 경우 코드에서 별도로 에러 메시지를 정의하지 않고도 간편하게 예외처리를 할 수 있다.

### 예제2

```python
try:
    print("나누기 전용 계산기입니다.")
    nums = []
    nums.append(int(input("첫 번째 숫자를 입력하세요 : ")))
    nums.append(int(input("두 번째 숫자를 입력하세요 : ")))
    nums.append(int(nums[0] / nums[1])) # 계산 결과를 리스트에 추가
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)
```

만약에 계산 결과를 리스트에 추가하는 부분을 깜빡했다면 어떻게 될까? 아래와 같이 임시로 주석처리를 해보자.

```python
try:
    print("나누기 전용 계산기입니다.")
    nums = []
    nums.append(int(input("첫 번째 숫자를 입력하세요 : ")))
    nums.append(int(input("두 번째 숫자를 입력하세요 : ")))
    # nums.append(int(nums[0] / nums[1])) # 계산 결과를 리스트에 추가
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)
```

프로그램 실행 후에 6과 3을 입력해보면 새로운 에러가 발생한다.

```python
# 실행 결과
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 3
Traceback (most recent call last):
  File "파일경로", line 38, in <module>
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
IndexError: list index out of range
```

`IndexError` 와 함께 에러 메시지가 출력되는데 그 이유는 현재 리스트에는 두 개의 수만 들어있으므로 index 기준으로는 [0], [1] 만 접근 가능한데 [2] 에 접근하려고 하니 사용 가능한 리스트의 범위를 벗어나서 발생하는 에러다.

이번에도 IndexError 구문을 추가할 수도 있겠지만 이런 식으로 **모든 에러에 대한 처리를 다 해주기는 어려운 경우도 있다.** 이 때는 다음과 같이 코드 마지막에 `except Exception as err:` 구문을 추가함으로써 **지금까지 정의되지 않은 모든 에러에 대한 처리가 가능**하다.

```python
try:
    print("나누기 전용 계산기입니다.")
    nums = []
    nums.append(int(input("첫 번째 숫자를 입력하세요 : ")))
    nums.append(int(input("두 번째 숫자를 입력하세요 : ")))
    # nums.append(int(nums[0] / nums[1])) # 계산 결과를 리스트에 추가
    print("{0} / {1} = {2}".format(nums[0], nums[1], nums[2]))
except ValueError:
    print("에러! 잘못된 값을 입력하였습니다.")
except ZeroDivisionError as err:
    print(err)
except Exception as err:
    print("알 수 없는 에러가 발생하였습니다.")
    print(err)
```

코드 실행 후 다시 한 번 6과 3을 입력해보면 다음과 같이 예외처리가 되는 것을 확인할 수 있다.

```python
# 실행 결과
나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요 : 6
두 번째 숫자를 입력하세요 : 3
알 수 없는 에러가 발생하였습니다.
list index out of range
```

## 10-2. 에러 발생시키기

이번에는 의도적으로 에러를 발생시키는 방법을 공부해보자.

실제로 에러 상황이 발생한 것이 아니라도 프로그램이 허용하지 않는 동작을 하려고 할 때 의도적으로 에러를 발생시킬 수 있으며 문법은 다음과 같다.

raise 에러종류

### 예제

계산기의 종류를 조금 바꿔서 한 자리 숫자에 대해서만 나누기를 할 수 있도록 해보자. 다만 나눗셈을 하기 전에 사용자로부터 입력받은 값들이 한 자리 숫자가 맞는지 확인하여 조건에 맞지 않을 때는, 즉 **10 이상일 때는 의도적으로 ValueError 를 발생시키고 except 를 통해 예외처리**를 하도록 하겠습니다.

```python
try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10: # 입력받은 수가 한 자리인지 확인
        raise ValueError
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
```

프로그램을 실행시키고 일부러 에러 상황을 만들기 위해서 첫 번째 숫자를 두 자리인 10으로 입력하고 두 번째 숫자는 5로 해보자.

```python
# 실행 결과
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.
```

이번에는 if 문에 의해서  ValueError가 발생하였고 이에 따라 예외 처리 구문에 작성한 print() 의 내용이 출력되는 것을 알 수 있다.

## 10-3. 사용자 정의 예외처리

파이썬에서는 필요에 따라 사용자가 새롭게 에러를 정의하고 그에 대한 예외처리를 할 수도 있다. 

### 예제

앞에서 만든 한 자리 숫자 나누기 전용 계산기 프로그램에서 실수로 두 자리 이상의 수를 입력했을 때 사용자가 입력한 값 중 어떤 값이 잘못되었는지를 보다 자세히 알려주도록 코드를 수정해보자.

먼저 두 자리 이상의 수를 입력해서 발생한 에러라는 의미로 BigNumberError 라는 클래스를 만들고 **파이썬에서 이미 정의되어 있는 Exception 이라는 클래스를 상속**받도록 한다. 이렇게 하면 앞에서 봤던 ValueError, IndexError 와 비슷하게 사용자가 필요로 하는 어떤 새로운 형태의 Error 를 정의할 수 있다. 클래스의 내용은 일단은 pass 로 두자.

그리고 입력값이 10 이상인지를 확인하는 if 구문에서 ValueError 대신 새롭게 정의한 BigNumberError 를 발생시키고, except 구문을 추가함으로써 새로운 에러에 대한 예외 처리를 하도록 한다.

```python
class BigNumberError(Exception): # 사용자 정의 에러
    pass

try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10: # 입력받은 수가 한 자리인지 확인
        # raise ValueError
        raise BigNumberError # 사용자 정의 에러
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
except BigNumberError: # 사용자 정의 예외 처리
    print("에러가 발생하였습니다. 한 자리 숫자만 입력하세요.")
```

프로그램을 실행하고 10 과 5 를 순차적으로 입력해보면 BigNumberError 가 발생했고 이에 대한 예외처리가 되어서 마지막에 추가한 문장이 잘 출력되는 것을 확인할 수 있다.

```python
# 실행 결과
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.
```

이렇게만 해서는 ValueError 와 큰 차이가 없으므로 이번에는 BigNumberError 의 내용을 채워보자.

pass 부분 대신 __init__() 생성자와 __str__() 메소드를 추가한다. 생성자에서는 에러 메시지를 의미하는 msg 를 전달받아서 멤버변수로 설정하고, __str__() 메소드에서는 멤버변수 msg 를 반환해주도록 한다. 이제 BigNumberError 를 발생시킬 때 필요한 문구를 추가하여 보다 자세한 에러 내용을 출력할 수 있다.

```python

class BigNumberError(Exception): # 사용자 정의 에러
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg
```

try 구문 내에서는 BigNumberError 를 발생시키는 부분의 코드를 보완하여 에러가 발생하는 시점에 어떤 값들이 입력되었는지를 문자열 형태로 작성한다. 이 내용이 바로 **init**() 생성자의 msg 로 들어가게 된다. 그리고 except 구문에서는 as 를 이용하여 err 이라는 이름으로 에러를 받고 이를 print() 를 통해 출력하면 **str**() 메소드에 의해 반환되는 msg 멤버변수가 출력된다.

```python
try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10: # 입력받은 수가 한 자리인지 확인
        raise BigNumberError("입력값 : {0}, {1}".format(num1, num2)) # 자세한 에러 메시지
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
except BigNumberError as err:
    print("에러가 발생하였습니다. 한 자리 숫자만 입력하세요.")
    print(err) # 에러 메시지 출력
```

프로그램을 실행하고 10 과 5 를 순차적으로 입력하면 이번에는 에러내용과 함께 사용자가 입력한 값도 함께 출력해준다.

```python
# 실행 결과
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.    
입력값 : 10, 5
```

사실 BigNumberError 의 **init**() 생성자와 **str**() 메소드는 따로 정의하지 않고 그냥 pass 로만 두어도 동일하게 동작한다. 하지만 생성자에서 추가로 어떤 작업을 해야 한다거나 **str**() 메소드에서 에러 메시지를 에러 코드 등과 함께 출력하고 싶은 경우에 다음과 같이 코드를 수정할 수 있다.

```python
class BigNumberError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return "[에러코드 001] " + self.msg # 에러 메시지 가공
```

변경된 코드를 실행한 결과는 다음과 같다.

```python
# 실행 결과
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.
[에러코드 001] 입력값 : 10, 5
```

## 10-4. finally

try 구문을 사용할 때 `finally` 라는 게 있다. `finally` 는 **try 구문 내에서 에러가 발생하건 말건 try 를 벗어나는 시점에 무조건 실행되는 구문**이다. finally 는 try 와 except 로 이루어진 구문의 맨 밑에 정의한다.

```python
try:
    실행 명령문1
    실행 명령문2
    ...
except 에러 종류1:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
except 에러 종류2:
    예외 처리 명령문1
    예외 처리 명령문2
    ...
finally:
    실행 명령문1
    실행 명령문2
    ...
```

### 예제

앞에서 만든 계산기 프로그램의 맨 밑에 finally 구문을 추가하자. 계산기를 이용해준 모든 분들께 감사하다는 인사 메시지를 출력한다.

```python
class BigNumberError(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

try:
    print("한 자리 숫자 나누기 전용 계산기입니다.")
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    if num1 >= 10 or num2 >= 10:
        raise BigNumberError("입력값 : {0}, {1}".format(num1, num2))
    print("{0} / {1} = {2}".format(num1, num2, int(num1 / num2)))
except ValueError:
    print("잘못된 값을 입력하였습니다. 한 자리 숫자만 입력하세요.")
except BigNumberError as err:
    print("에러가 발생하였습니다. 한 자리 숫자만 입력하세요.")
    print(err)
finally: # 에러 발생 여부 상관 없이 항상 실행
    print("계산기를 이용해 주셔서 감사합니다.")
```

프로그램을 실행시키고 6과 2를 순서대로 입력하여 정상적으로 계산이 되도록 한다.

```python
# 실행 결과
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 6
두 번째 숫자를 입력하세요: 2
6 / 2 = 3
계산기를 이용해 주셔서 감사합니다.
```

이번에는 일부러 에러를 발생시키기 위해 10과 5를 순서대로 입력한다.

```python
한 자리 숫자 나누기 전용 계산기입니다.
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
에러가 발생하였습니다. 한 자리 숫자만 입력하세요.
입력값 : 10, 5
계산기를 이용해 주셔서 감사합니다.
```

에러가 발생하고 한 자리 숫자만 입력하라는 에러 메시지와 함께 finally 구문이 실행되는 것을 볼 수 있다.

이와 같이 **try 구문의 마지막에 finally 를 추가함으로써 에러 발생 여부 상관 없이 항상 실행되는 코드를 작성할 수 있는데,** 일반적으로 try 구문 내에서 파일이나 자원을 사용한 경우 finally 구문에서 열린 파일을 닫거나 자원을 해제하는 작업을 수행한다. 이렇게 하면 프로그램이 실행되는 과정에서 에러가 발생하고 올바른 예외처리가 되지 않은 경우라도 **항상 자원이 정상적으로 해제되는 것을 보장**할 수 있습니다.

마치 시험을 앞둔 어느 학생이 쉬는 시간에 여러 책을 마구 펼쳐놓고 열심히 공부하다가 시험 시간이 되면 공부가 끝나건 말건 상관 없이 모든 책을 덮는 것과 비슷하다고 이해하면 된다. 이 때 쉬는 시간이 try 구문이 실행되는 부분이며 시험 시간이 try 구문 탈출과 함께 실행되는 finally 구문이 된다.

# 11. 모듈과 패키지

## 11-1. 모듈

소프트웨어는 부품만 교체하거나 추가할 수 있도록 만들면 유지보수도 쉽고 코드의 재사용도 수월해지는 장점이 있다.

**함수 정의나 클래스 등 서로 관련이 있거나 비슷한 기능을 하는 파이썬 문장들을 담고 있는 파일**을 `모듈(module)` 이라고 하며, **필요한 것들끼리 부품처럼 잘 만드는 것**을 `모듈화(modularization)` 라고 한다.

### 예제

사람 수에 따른 영화표 가격을 계산해주는 3개 함수를 정의할텐데, 각 함수는 사람 수를 의미하는 people을 전달받으며 1인당 영화표 가격은 price() 함수에서는 일반 가격인 10,000원, price_morning() 에서는 조조 할인 가격인 6,000원, price_soldier() 에서는 군인 할인 가격인 4,000원으로 계산하여 출력한다.

```python
# 일반 가격
def price(people):
    print("{0}명 가격은 {1}원 입니다.".format(people, people * 10000))

# 조조 할인 가격
def price_morning(people):
    print("{0}명 조조 할인 가격은 {1}원 입니다.".format(people, people * 6000))

# 군인 할인 가격
def price_soldier(people):
    print("{0}명 군인 할인 가격은 {1}원 입니다. ".format(people, people * 4000))
```

이제 이 파일은 모듈이 되며 다른 파일에서 가져다가 사용할 수 있다. 원래 사용하던 파일에서 모듈을 사용해볼 수 있는데, theater_module.py 파일과 이 모듈을 사용할 파일은 **서로 같은 경로상에** 있어야 한다.

### 모듈 사용 방법 #1. import

모듈을 사용하는 방법에는 여러 가지가 있는데 가장 기본적인 `import`를 먼저 보자. import 구문을 쓸 때는 파일명 theater_module.py 에서 확장자 .py 를 제외한 모듈 이름 theater_module 을 그대로 적어주면 된다. import를 한 이후부터는 이 모듈에 정의한 함수를 사용할 수 있는데 **모듈명 뒤에 점(.)을 찍고 나서 함수 이름**을 적는다.

```python
import theater_module # theater_module 을 가져다가 사용
theater_module.price(3) # 3명이 영화보러 갔을 때 가격
theater_module.price_morning(4) # 4명이 조조 영화 보러 갔을 때 가격
theater_module.price_soldier(5) # 5명의 군인이 영화 보러 갔을 때 가격
```

```python
# 실행 결과
3명 가격은 30000원 입니다.
4명 조조 할인 가격은 24000원 입니다.
5명 군인 할인 가격은 20000원 입니다.
```

### 모듈 사용 방법 #2. import ~ as

그런데 theater_module 이라는 이름이 다소 길어서 모듈을 사용할 때마다 긴 이름을 적는 것이 조금 불편하다. 이럴 때는 `as` 를 이용해서 **모듈에 별명을 붙여줄 수 있다.** 영화는 영어로 movie 인데 이것도 길어 보이니 편의상 mv 라는 별명을 짓도록 하자. import 구문 뒤에 as mv 를 붙여서 theater_module 이라는 이름을 mv 로 간편하게 호출할 수 있다.

```python
import theater_module as mv # theater_module 을 새로운 별명인 mv 로 사용
mv.price(3)
mv.price_morning(4)
mv.price_soldier(5)
```

### 모듈 사용 방법 #3. from ~ import

```python
from theater_module import *
```

from 뒤에 모듈 이름을 적고 그 모듈 내에서 가져다가 사용할 부분을 import 뒤에 적어주면 된다. 우선은 **모든 부분을 가져다 쓴다는 의미**로 `*`을 적어보자. `from ~ import` 구문을 통해 가져온 모듈은 **모듈명과 점(.) 부분을 적어줄 필요 없이 모듈 내의 함수 이름을 그대로** 적으면 된다.

```python
from theater_module import * # theater_module 내에서 모든 것을 가져다가 사용
price(3) # theater_module. 필요 없음
price_morning(4)
price_soldier(5)
```

때로는 모듈 내에 정의된 모든 내용을 가져다 쓰지 않고 필요한 것만 가져다가 써야할 때도 있다. 예를 들어서 이미 군대를 전역한 사람이라면 군인 할인 가격에 해당하는 price_soldier() 함수는 아무런 쓸모가 없을 것이다. 이 때는 from ~ import 구문 뒤에 * 대신 **사용하고자 하는 부분만 콤마(,)로 구분하여** 적으면 된다. 

```python
from theater_module import price, price_morning # 모듈에서 일부만 가져다가 사용
price(5) # 이번에는 5명
price_morning(6)
price_soldier(7) # import 하지 않았으므로 사용 불가
```

```python
# 실행 결과
5명 가격은 50000원 입니다.
6명 조조 할인 가격은 36000원 입니다.
Traceback (most recent call last):
  File "파일 경로", line 23, in <module>
    price_soldier(7)
NameError: name 'price_soldier' is not defined
```

실행시켜보면 price() 와 price_morning() 은 정상적으로 결과가 출력되는데 price_soldier() 부분은 import 를 하지 않았으므로 정의되지 않은 이름이라고 하며 에러가 발생하는 것을 확인할 수 있다.

### 모듈 사용 방법 #4. from ~ import ~ as

앞에서는 군대를 전역한 사람을 예로 들었는데 만약 현재 군생활을 하고 있는 군인이라면 어떨까? 일반 가격 (10,000원) 이나 조조 할인 가격 (6,000원) 보다 군인 할인 가격 (4,000원) 이 더 저렴하므로 price() 와 price_morning() 을 사용할 필요 없이 항상 price_soldier() 를 사용하면 된다. 그런데 price_soldier() 라는 이름이 조금 길고 어차피 다른 함수는 사용하지 않으므로 새로운 별명인 price 를 사용하도록 하자.

```python
from theater_module import price_soldier as price # price_soldier를 새로운 별명인 price로 사용
price(5) # price_soldier()를 호출
```

```python
# 실행 결과
5명 군인 할인 가격은 20000원 입니다.
```

## 11-2. 패키지

마치 여행사 패키지 상품을 통해 항공, 숙소, 차량을 한꺼번에 예약할 수 있는 것처럼 파이썬에서는 **여러 모듈들을 모아 놓은 집합**을 `패키지`라고 하며, 패키지는 **보통 하나의 폴더 안에 여러 모듈 파일들로 구성**된다.

### 예제

이해를 돕기 위해 신규 여행사 관련 프로젝트를 담당하게 되었다고 가정해보자. 이 여행사는 태국과 베트남 패키지 여행 상품을 제공한다.

Visual Studio Code 에서 새로운 폴더를 하나 만들고 이름은 `travel` 로 하여 새로운 패키지를 생성한다. 그리고 travel 폴더 밑에 태국 패키지 상품을 위한 모듈인 [`thailand.py`](http://thailand.py/) 파일, 그리고 베트남 패키지 상품을 위한 모듈인 [`vietnam.py`](http://vietnam.py/) 파일을 만들자. 마지막으로 `__init__.py`라는 파일도 함께 만들어보자.

```
travel
 ├  __init__.py
 ├  thailand.py
 └  vietnam.py
```

먼저 태국 여행 패키지 상품을 위한 `[thailand.py](http://thailand.py)` 파일에 내용을 채워보자. ThailandPackage란 이름의 클래스를 만들고 detail() 이라는 메소드를 하나 정의하는데 이 메소드가 호출되면 태국 패키지 상품에 대한 요약 정보가 출력되도록 한다.

```python
class ThailandPackage:
		def detail(self):
				print("[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원")
```

비슷한 형태로 `[vietnam.py](http://vietnam.py)` 파일에 VietnamPackage란 이름으로 베트남 여행 패키지 클래스도 정의해보자.

```python
class VietnamPackage:
		def detail(self):
				print("[베트남 패키지 3박 5일] 다낭 효도 여행 60만원")
```

`__init__.py` 는 일단은 그대로 두고, 기존에 연습하던 [practice.py](http://practice.py) 파일에서 travel 패키지를 사용해보자.

### 패키지 import

[practice.py](http://practice.py/) 에서는 travel 패키지의 thailand 모듈을 import 하고, 모듈에 정의된 ThailandPackage 객체를 만들고 detail() 메소드를 호출해보자.

import *패키지.모듈*

```python
import travel.thailand
trip_to = travel.thailand.ThailandPackage()
trip_to.detail()
```

사용할 때는 *패키지이름.모듈이름.함수이름()*

```python
# 실행 결과
[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원
```

import 구문을 사용할 때는 그 대상이 모듈이나 패키지여야 하며, 클래스나 함수는 import를 할 수 없다.

```python
import travel.thailand.ThailandPackage # 클래스 직접 import 불가
trip_to = travel.thailand.ThailandPackage()
trip_to.detail()
```

import 구문을 위처럼 변경하면 다음과 같은 에러가 발생한다.

```python
ModuleNotFoundError: No module named 'travel.thailand.ThailandPackage'; 'travel.thailand' is not a package
```

### 패키지 from ~ import #1

from ~ import 구문을 사용하면 모듈, 패키지, 클래스, 함수 모두 import 를 할 수 있다.

from *패키지.모듈* import *클래스*

```python
from travel.thailand import ThailandPackage # travel.thailand 모듈에서 ThailandPackage 클래스 가져오기
trip_to = ThailandPackage() # travel.thailand. 는 생략
trip_to.detail()
```

이 때는 import 한 클래스 객체를 생성할 때 앞에서 했던 것과는 다르게 travel.thailand 부분은 생략하고 클래스 이름인 ThailandPackage를 통해 접근 가능하다.

### 패키지 from ~ import #2

from *패키지* import *모듈*

```python
from travel import vietnam # travel 패키지에서 vietnam 모듈 가져오기
trip_to = vietnam.VietnamPackage() # travel. 은 생략
trip_to.detail()
```

어떤 대상을 import 하느냐에 따라서 대상 내에 접근하기 위한 코드도 달라져야 한다는 점을 주의하자.
## 11-3. __all__

```python
from travel import *
trip_to = vietnam.VietnamPackage() # 베트남
trip_to.detail()
```

을 실행시켜보면 vietnam이 정의되지 않았다며 에러가 발생한다.

NameError: name 'vietnam' is not defined

왜 그럴까?

`*` 을 쓴다는 것의 의미는 travel 이라는 패키지에 있는 모든 것을 가져다 쓰겠다는 것인데, 실제로는 패키지를 만든 사람이 공개 범위를 설정해줄 수가 있다. 즉, 패키지에 포함된 모듈 중에서 import 되기를 원하는 것만 공개를 하고 나머지는 비공개로 둘 수 있다.

travel 패키지를 만들 때 함께 생성했던 `__init__.py` 파일을 열어서 다음과 같이 내용을 작성한다. `__all__` 이라는 변수에 리스트 형태로 공개하려는 모듈 이름을 추가하면 해당 모듈에 대해 공개 설정을 할 수 있게 된다. 이 때, `__all__` 앞 뒤로 밑줄은 2번씩 적어야 한다는 점 주의하자.

```python
__all__ = ["vietnam"] # vietnam 모듈 공개
```

```python
# 실행 결과
[베트남 패키지 3박 5일] 다낭 효도 여행 60만원
```

베트남 패키지 상품 정보가 잘 출력되는 것을 확인할 수 있다.

이번에는 VietnamPackage 부분은 주석 처리를 하고 다음 줄에 ThailandPackage 객체를 만들도록 하자.

```python
from travel import *
# trip_to = vietnam.VietnamPackage()
trip_to = thailand.ThailandPackage() # 태국
trip_to.detail()
```

실행시켜보면 앞에서 발생한 에러가 모듈 이름만 바껴서 똑같이 나타난다.

NameError: name 'thailand' is not defined

이는 현재 travel 패키지의 __init__.py 파일 안에서 __all__ 에는 vietnam 만 포함되어 있기 때문에, 즉 vietnam 모듈만 공개되고 있기 때문에 thailand 모듈은 사용이 불가한 것이다.

에러를 해결하기 위해 __init__.py 파일을 열어서 리스트에 thailand 모듈을 추가한 후 저장한다. 이제 vietnam 과 thailand 모듈 모두 공개 설정이 된 상태다.

```python
__all__ = ["vietnam", "thailand"] # vietnam, thailand 모듈 공개
```

다시 코드를 실행해보면 이번에는 thailand 모듈에도 이상 없이 접근하여 올바른 동작을 하는 것을 확인할 수 있다.

```python
# 실행 결과
[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원
```

## 11-4. 모듈 직접 실행

실제로 모듈을 만들게 되면 규모나 복잡도에 따라 모듈 내 기능이 올바르게 동작하는지를 확인하는 작업이 반드시 필요하다. 물론 지금까지 배웠던 것처럼 별도의 파일에서 해당 모듈을 import 해와서 테스트를 해볼 수도 있겠지만 모듈을 직접 실행하면서 확인하는 방법이 아무래도 수월하다.

모듈이 직접 실행되는지, 아니면 별도의 파일에서 호출되어 실행되는지는 이렇게 구분할 수 있다. 이 때 `__name__` 과 `"__main__"`은 앞 뒤로 밑줄을 2번씩 적어야 한다는 점 주의하자.

```python
if __name__ == "__main__": # 직접 실행되는 경우
    pass
else: # 외부에서 호출되어 실행되는 경우
    pass
```

### 예제

앞에서 만든 travel 패키지의 [`thailand.py`](http://thailand.py/) 파일에서 ThailandPackage 클래스 정의부분 밑에 코드를 추가해보자. if 구문을 통해 `__name__` 이 `"__main__"` 인 경우, 즉 이 모듈이 직접 실행되는 경우에는 출력문과 함께 ThailandPackage 객체를 만들어서 detail() 메소드를 호출하는 작업까지 해보자. else 구문에서는, 즉 모듈이 외부에서 호출되는 경우에는 외부에서 호출된다는 문구만 간략히 출력하도록 한다.

```python
class ThailandPackage:
    def detail(self):
        print("[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원")
        
if __name__ == "__main__": # 모듈 직접 실행
    print("Thailand 모듈을 직접 실행")
    print("이 문장은 모듈을 직접 실행할 때만 실행돼요")
    trip_to = ThailandPackage()
    trip_to.detail()
else: # 외부에서 모듈 호출
    print("Thailand 외부에서 모듈 호출")
```

먼저 모듈을 직접 실행할 때의 동작을 확인하기 위해 [`thailand.py`](http://thailand.py/) 파일을 연 상태에서 실행 버튼을 클릭한다. 출력 결과를 보면 if 조건에 해당하는 구문이 실행된 것을 확인할 수 있다.

```python
# 실행 결과
Thailand 모듈을 직접 실행
이 문장은 모듈을 직접 실행할 때만 실행돼요
[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원
```

이번에는 앞 장에서 작성한 내용 그대로 [`practice.py`](http://practice.py/) 파일에서 thailand 모듈을 가져다 써보도록 하자.

```python
from travel import *
trip_to = thailand.ThailandPackage()
trip_to.detail()
```

실행을 해보면 thailand 모듈 내에 정의된 else 구문의 문장이 실행되고 나서 detail() 메소드의 동작이 실행되는 것을 확인할 수 있다.

```python
# 실행 결과
Thailand 외부에서 모듈 호출
[태국 패키지 3박 5일] 방콕, 파타야 여행 (야시장 투어) 50만원
```

`if __name__ == "__main__":` 구문을 잘 활용하면 모듈을 직접 실행하는지, 또는 외부에서 가져다 쓰는지를 구분하여 필요한 코드를 작성할 수 있다.

## 11-5. 패키지, 모듈 위치

패키지나 모듈은 호출을 하려는 파일과 **동일한 경로**에 있거나 또는 파이썬 라이브러리들이 모여 있는 폴더에 있어야 사용이 가능하다. 

파이썬에서는 사용하려는 모듈이 어느 경로에 있는지 확인할 수 있는 방법이 있다. 우리가 자주 쓰던 random 모듈에 대한 경로를 먼저 확인하기 위해 inspect 라는 모듈을 import 하고 getfile() 이라는 함수에 전달값으로 random 을 적는다.

```python
import inspect
import random
print(inspect.getfile(random)) # random 모듈의 위치
```

실행해보면 다음과 같이 [random.py](http://random.py/) 파일이 존재하는 위치가 표시된다. 처음에 환경설정을 진행하는 과정에서 파이썬을 설치할 때 지정한 경로 밑의 lib 폴더인 것을 확인할 수 있다.

```python
# 실행 결과
/opt/homebrew/Cellar/python@3.9/3.9.6/Frameworks/Python.framework/Versions/3.9/lib/python3.9/random.py
```

### 예제

이번에는 직접 만든 travel 패키지의 thailand 모듈이 어느 경로에 위치하는지 확인해보기 위해 코드를 다음과 같이 작성한다.

```python
import inspect
from travel import *
print(inspect.getfile(thailand)) # thailand 모듈의 위치
```

실행해보면 thailand 모듈이 외부에서 호출된다는 문구와 함께 경로 정보가 표시된다.

```python
# 실행 결과
Thailand 외부에서 모듈 호출
/Users/eun/Desktop/TIL/강의/파이썬 기초/travel/thailand.py
```

패키지나 모듈은 "**파이썬 라이브러리들이 모여 있는 폴더**" 에 있으면 사용 가능하다. 확인을 위해 travel 패키지 폴더를 lib 폴더로 복사해보자. 폴더 복사를 위해서는 파일 탐색기를 직접 실행하여 작업 중인 폴더로 이동해도 되고, 또는 Visual Studio Code 에서 travel 폴더를 마우스 오른쪽 버튼으로 클릭하여 Reveal in File Explorer 메뉴를 선택해도 된다.

## 11-6. pip install

파이썬의 강점 중 하나는 유용한 패키지가 아주 많이 존재한다는 것이다. 지금도 전 세계 각지에서 누군가는 새로운 패키지를 개발하고 있어서 그 수는 점점 늘어가고 있다. 그렇기 때문에 파이썬으로 개발을 할 때 어떤 기능이 필요하다고 하면 무작정 처음부터 개발하기보다는 이미 잘 만들어진 패키지가 있지는 확인을 해보고 잘 가져다가 쓰는 것도 무척 중요하다.

### 파이썬 패키지 찾아보는 법

브라우저를 열고 구글에서 `pypi` 라고 검색을 하면 첫 페이지에 나오는 [`pypi.org`](http://pypi.org/) 를 확인할 수 있는데 이 곳을 방문한다. 또는 주소창에 바로 [`https://pypi.org`](https://pypi.org/) 라고 입력을 하는 방법도 있다.

### 패키지 설치하기

![package_download.png](/img/package_download.png)

패키지 설치 명령 복사 버튼

Visual Studio Code 의 터미널 탭에서 마우스 오른쪽 버튼을 클릭하여 명령어를 붙여넣기 (또는 직접 입력) 한 뒤에 Enter 를 누르면 패키지 설치가 진행된다.

pip install [패키지]

pip 명령은 패키지 설치 외에도 다양한 명령을 수행할 수 있다.

[pip 명령](https://www.notion.so/a29468fc939a40d780316e06dbfe9046)

## 11-7. 내장함수

파이썬에는 `내장 함수(built-in function)` 가 있다. 내장 함수란 **별도로 import 를 하지 않고도 사용할 수 있도록 내장되어 있는 함수**를 의미한다. 사용자의 입력을 받기 위한 `input()` 함수도 내장 함수 중 하나이다. 사용자로부터 좋아하는 언어를 입력 받고 문장을 출력하는 간단한 코드를 작성해보자.

```python
language = input("무슨 언어를 좋아하세요? ")
print("{0}은 아주 좋은 언어입니다!".format(language))
```

프로그램을 실행시키고 "파이썬" 이라는 값을 입력하면 language 라는 변수에 저장을 했다가 print() 문을 통해서 출력한다. 이 때 내장함수인 input() 을 쓰기 위해 별도로 해줘야 하는 것은 아무것도 없다.

### dir() 함수

`dir()` 은 어떤 객체를 넘겼을 때 그 객체가 어떤 변수와 함수를 가지고 있는지 알려주는 목적으로 사용할 수 있는 내장함수이다. 만약 전달값으로 아무것도 넘기지 않는다면 현재 소스코드 범위 내에서 사용 가능한 모듈 또는 객체가 출력된다.

비교를 위해서 아무것도 import 하지 않았을 때의 dir() 함수 출력결과와 random, pickle 모듈을 import 했을 때의 출력결과를 확인하는 코드를 작성해보자.

```python
print(dir())
import random # random 모듈 가져다 쓰기
print(dir())
import pickle # pickle 모듈 가져다 쓰기
print(dir())
```

실행시켜보면 처음에는 기본 값들만 출력되고 import random 다음에는 random 모듈이, import pickle 다음에는 pickle 모듈이 포함되어 코드 내에서 사용할 수 있음을 확인할 수 있다.

이번에는 random 모듈을 직접 전달값으로 설정해보자.

```python
import random
print(dir(random))
```

실행 결과 random 모듈 내에서 사용 가능한 모든 것들이 출력되는 것을 확인할 수 있다. 이미 우리가 사용해봤던 randint, randrange, sample, shuffle 등 익숙한 이름들도 확인할 수 있다.

모듈이 아닌 리스트 자료구조를 하나 만들어서 확인해보자. lst란 이름의 리스트에 숫자 몇 개를 추가하는 코드를 작성한다.

```python
lst = [1, 2, 3]
print(dir(lst))
```

실행시켜보면 리스트에서 사용 가능한 변수와 함수 목록들이 보여진다. 리스트 자료구조를 공부할 때 봤던 append, clear, count, extend, index, reverse, sort 등의 함수 이름도 확인할 수 있다.

이번에는 더 기본적인 문자열 변수를 하나 만들어서 확인해보자. name 이란 변수에 "Jim"이라는 값을 집어 넣고 dir()을 통해 사용 가능한 변수와 함수를 확인하는 코드를 작성한다.

```python
name = "Jim"
print(dir(name))
```

실행 결과 굉장히 많은 내용들이 출력되는데 name 이라는 문자열 변수에 대해서 대문자로 변경하는 upper, 특정 문자를 찾는 find 등 다양한 기능을 ㅏ용할 수 있다는 것을 확인할 수 있다.

파이썬에서 제공되는 내장 함수에 대한 더 자세한 내용은 구글에서 `"list of python builtins"` 로 검색하면 나오는 파이썬 공식 홈페이지의 [Built-in Functions 페이지](https://docs.python.org/ko/3/library/functions.html)에 방문하여 확인할 수 있다.

## 11-8. 외장함수

내장 함수와는 다르게 외장 함수를 사용하기 위해서는 반드시 해당 모듈을 import 해야 한다. 먼저 파이썬에서 제공되는 모듈을 살펴보기 위해서 구글에서  `"list of python modules"` 로 검색해보자.

[Python Module Index](https://docs.python.org/ko/3/py-modindex.html)

### glob 모듈

`glob` 은 어떤 경로 내의 폴더 또는 파일의 목록을 조회할 때 사용하며 윈도우에서는 dir 명령과 비슷하다. glob 모듈에는 `glob()` 이라는 함수가 있는데 파일 이름 또는 형태를 넘기면 그에 해당하는 파일이 조회된다. 

예제 코드에서는 import 를 통해 glob 모듈을 가져다 쓰도록 하고 glob() 함수에는 **모든 것을 의미**하는 `*` 와 **파이썬 파일 확장자를 의미**하는 `.py` 를 합친 `*.py` 를 전달함으로써 확장자가 py 인 모든 파일의 목록을 출력해보자.

```python
import glob
print(glob.glob("*.py")) # 확장자가 py 인 모든 파일
```

실행을 해보면 현재 작업 공간에 존재하는 .py 로 끝나는 모든 파일이 출력되는 것을 확인할 수 있다.

### os 모듈

`os` 는 **운영체제에서 제공하는 기본 기능** 정도로 생각하면 된다. 예를 들어서 폴더를 만들거나 삭제하는 기능을 수행할 수 있다. 

우선 현재 파이썬 파일이 실행되는 디렉토리 정보를 출력하는 간단한 코드를 작성해보자. os 모듈을 import 하고 `getcwd()` 함수를 호출하는데 이 때 cwd 는 current working directory 로 현재 작업 디렉토리를 의미한다.

```python
import os
print(os.getcwd()) # 현재 디렉토리
```

프로그램 실행 결과는 다음과 같다.

/Users/eun/Desktop/TIL

이번에는 폴더를 하나 만들어보자. folder 변수에 `"sample_dir"` 이란 값을 지정하고, os 모듈이 제공하는 기능 중 **주어진 경로에 해당하는 폴더 또는 파일이 존재하는지 여부를 알려주는** `os.path.exists()` 함수를 통해서 folder 변수와 동일한 이름의 폴더가 존재하는지를 확인한다. 확인 결과 폴더가 존재하지 않는 경우에만 `makedirs()` 함수를 통해서 **새로운 폴더를 생성**하도록 한다.

```python
import os

folder = "sample_dir"

if os.path.exists(folder): # 폴더가 존재한다면
    print("이미 존재하는 폴더입니다.")
else: # 폴더가 존재하지 않으면
    os.makedirs(folder) # 폴더 생성
    print(folder, "폴더를 생성하였습니다.")
```

프로그램을 실행시켜보면 Visual Studio Code 좌측 EXPLORER 탭에 `sample_dir` 이라는 폴더가 새로 생기고 다음 문장이 출력되는 것을 확인할 수 있다.

sample_dir 폴더를 생성하였습니다.

다시 한 번 프로그램을 실행시키면 이미 sample_dir 폴더가 존재하기 때문에 출력 결과는 달라진다.

이미 존재하는 폴더입니다.

폴더가 존재하는 경우 **해당 폴더를 삭제**하도록 if 구문을 조금 수정해보자. os 모듈의 `rmdir()` 함수를 이용하여 folder 변수를 전달하면 되는데 이 때 rm 은 삭제를 의미하는 remove 의 줄임말이다.

```python
...

if os.path.exists(folder):
    print("이미 존재하는 폴더입니다.")
    os.rmdir(folder) # 폴더 삭제
    print(folder, "폴더를 삭제하였습니다.") # 삭제 문구 출력
else:
    os.makedirs(folder)
    print(folder, "폴더를 생성하였습니다.")
```

한 번 더 프로그램을 실행시켜보면 sample_dir 폴더는 삭제되며 관련 문구가 출력된다.

```python
# 실행 결과
이미 존재하는 폴더입니다.        
sample_dir 폴더를 삭제하였습니다.
```