# 1. 소개 & 환경설정

## 1-1. 소개

## 1-2. 환경설정

vscode

## 1-3. 파이썬 실행하기

# 2. 자료형

## 2-1~2-3. 숫자, 문자열, boolean 자료형

### 자료형

`숫자` : 정수 - 1, 2, 3 / 실수 - 1.0, 3.14

`문자` : "생일", "케이크

`불리안(boolean)` : 참(True), 거짓(False)

```python
#숫자 자료형
print(-10)
print(3.14)
print(100)

print(5+3) # 8 출력
print(2*8) # 16 출력 (주의 : x 가 아닌 * 예요)
print(3*(3+1)) # 12 출력

#문자열 자료형
print('풍선') # 작은 따옴표로 감싼 문자열 
print("나비") # 큰 따옴표로 감싼 문자열 
print("ㅋㅋㅋㅋㅋㅋㅋㅋㅋ") # 긴 문자열 
print("ㅋ"*9) # ㅋ 을 9번 출력

#boolean 자료형
print(5 > 10) # False 출력 
print(5 < 10) # True 출력

print(True) # True 
print(False) # False

print(not True) # False 출력 
print(not False) # True 출력 
print(not (5 > 10)) # True 출력
```

## 2-4. 변수

```python
name = "연탄이"
animal = "강아지"
age = 4
hobby = "산책"
is_adult = age >= 3

print("우리집 " + animal + "의 이름은 " + name + "에요")
print(name, "는 ", age, "살이며, ", hobby, "을 아주 좋아해요")
print(name + "는 어른일까요? " + str(is_adult))

👉🏻 우리집 강아지의 이름은 연탄이에요
연탄이는 4살이며, 산책을 아주 좋아해요
연탄이는 어른일까요? True
```

변수 특징

- 해당 변수를 사용하기 전에만 정의하면 OK
- 변수에 가장 마지막에 저장된 값을 사용
- '문자열 + 변수 + 문자열' 도 되고, '문자열, 변수, 문자열' 도 된다.  `+` 대신 `,` 를 사용하면 값과 값 사이에 **공백**이 하나 포함된다.
- boolean 자료형은 문자열과 조합할 때는 문자열로 바꿔주어야 한다. `str(is_adult)`
- 숫자 자료형을 문자열 자료형으로 바꿔서 출력하려면 `str(age)`

## 2-5. 주석

- 한 줄 주석은 `#`
- 여러 줄 주석은 `''' 주석 내용 '''`

# 3. 연산자

## 3-1. 연산자

[연산자](https://www.notion.so/b2a4669e67464c5f935b0ab74c472682)

연속적인 수식에 대해서도 연산 가능

```python
print(5 > 4 > 3) #(5 > 4)도 참이고 (4 > 3)도 참이므로 True
print(5 > 4 > 7) # (5 > 4) 는 참이지만 (4 > 7) 은 거짓이므로 False
```

이 때 a > b > c 연산은 a > b and b > c 연산과 동일하게 동작한다. 참고로 만약 a > b 가 거짓이라면 이후의 수식 결과와 상관 없이 항상 거짓이 되므로 b > c 연산은 수행하지 않는다.

## 3-2. 간단한 수식

`변수명 = 변수명 + 값` 을 간단하게 하면 `변수명 += 값`

(더하기 뿐 아니라 다른 연산자들도 같은 방식으로 적용가능)

## 3-3. 숫자처리함수

파이썬에서는 기본적으로 다음과 같은 여러 숫자 처리 함수를 제공해준다.

[숫자 처리 함수](https://www.notion.so/fb7d42f9ee2046f78e9666e791972deb)

[math 모듈](https://www.notion.so/6b5684c22a214e71946b63089ea5d794)

`모듈` 은 어떤 기능들을 모아놓은 파이썬 파일을 의미한다.

코드 내에서 모듈의 기능들을 가져다 쓰기 위해서는 아래와 같은 형태의 구문을 적어야 한다.

from *모듈이름* import *사용할 무언가*

```python
from math import * # math 모듈 내의 모든 내용을 가져다 쓰겠다는 의미

print(floor(4.99)) # 4.99 의 내림 = 4
print(ceil(3.14)) # 3.14 의 올림 = 4
print(sqrt(16)) # 16 의 제곱근 = 4
```

또 다른 방법

import *모듈이름*

단, 이 때는 모듈이름과 점(.)을 함께 적어야 한다.

```python
import math # math 모듈을 가져다 쓰겠다는 의미

print(math.floor(4.99)) # math. 과 함께 사용
print(math.ceil(3.14))
print(math.sqrt(16))
```

## 3-4. 랜덤함수

파이썬에는 무작위로 어떤 수를 뽑아주는 random 모듈이 있다.

```python
from random import * # random 모듈에서 모든 것들을 가져다 쓰겠다는 의미
print(random()) # 0.0 이상 1.0 미만의 임의의 값 생성

print(random() * 10) # 0.0 이상 10.0 미만의 임의의 값 생성
print(int(random() * 10)) # 0 이상 10 미만의 임의의 정수 값 생성
print(int(random() * 10) + 1) # 1 이상 10 이하 (11 미만) 의 임의의 정수 값 생성
```

1부터 45까지의 범위를 가지는 로또 번호를 뽑기 위해서는

```python
print(int(random() * 45) + 1) # 1 이상 46 미만의 임의의 정수 값 생성
```

보다 쉽게 원하는 범위 내의 랜덤 수를 뽑는 함수들

[랜덤 함수](https://www.notion.so/ba1260e275b0448bb58228e139ffbdb7)

# 4. 문자열 처리

## 4-1. 문자열

`문자열` 이란 문자들의 집합을 의미한다. 파이썬에서는 작은 따옴표 또는 큰 따옴표로 감싸서 문자열을 나타냄.

```python
sentence3 = """
나는 소년이고,
파이썬은 쉬워요
"""
print(sentence3) # 큰 따옴표 대신 작은 따옴표 3개씩으로 감싸도 돼요
```

문장 앞에 변수가 없으면 주석으로 인식된다는 점 주의! 

혼란을 줄이기 위해 가급적 주석은 작은 따옴표, 문자열은 큰 따옴표 사용을 권장.

## 4-2. 슬라이싱

여러 문자의 집합으로 구성된 문자열(또는 리스트 등)은 n번째 인덱스에 있는 문자(또는 데이터) 하나만을 가져올 수 있다.

→ `변수명[인덱스]`

인덱스는 1이 아닌 0부터 시작한다는 것 주의!

**슬라이싱: `변수명[시작인덱스:종료인덱스]`**

시작인덱스 값은 포함하고, 종료인덱스 값은 포함하지 않는다.(종료인덱스의 직전 값까지 포함)

`변수명[:인덱스]` :처음부터 인덱스 직전까지 슬라이싱

`변수명[인덱스:]` :인덱스부터 끝까지 슬라이싱

`변수명[:]` :처음부터 끝까지 슬라이싱

`변수명[인덱스의 음수값:]` :뒤에서 부터 슬라이싱 하기

*맨 처음의 인덱스는 [0], 맨 뒤의 인덱스는 [-1] 이라는 점 주의

## 4-3. 문자열처리함수

문자열을 편리하게 다루기 위한 함수

[문자열 관련 함수](https://www.notion.so/f89c737f7db64ffa904bf14932f5cd22)

```python
python = "Python is Amazing"

print(python.lower()) # python is amazing
print(python.upper()) # PYTHON IS AMAZING
print(python[0].isupper()) # True : 0 번째 인덱스의 값이 대문자인지 확인
print(len(python)) # 17 : 띄어쓰기를 포함한 문자열의 전체 길이 (length)
print(python.replace("Python", "Java")) # Java is Amazing

index = python.index("n") # 처음으로 발견된 n 의 인덱스
print(index) # 5 : Python 의 n
index = python.index("n", index + 1) # 6 번째 인덱스 이후에 처음으로 발견된 n 의 인덱스 
print(index) # 15 : Amazing 의 n

find = python.find("n") # 처음으로 발견된 n 의 인덱스
print(find) # 5 : Python 의 n
find = python.find("n", find + 1) # 6 번째 인덱스 이후에 처음으로 발견된 n 의 인덱스 
print(find) # 15 : Amazing 의 n

print(python.index("Java")) # Java 가 없기 때문에 에러가 발생하며 프로그램 종료
print(python.find("Java")) # Java 가 없으면 -1 을 반환(출력)하며 프로그램 계속 수행

print(python.count("n")) # 2 : 문자열 내에서 n 이 나온 횟수
```

## 4-4. 문자열포맷

```python
print("a" + "b") # ab
print("a", "b") # a b
```

이외에도 다양한 포맷으로 문자열을 출력하는 방법이 있다.

### 첫 번째 방법, %

**print("문자열 %d 문자열" % 정수)**

**print("문자열 %c 문자열" % 문자)**

**print("문자열 %s 문자열" % 문자열)**

```python
# 방법 1

print("나는 %d살입니다." % 20) # 나는 20살입니다
print("나는 %s을 좋아합니다." % "파이썬") # 나는 파이썬을 좋아합니다.
print("Apple 은 %c로 시작해요." % "A") # Apple 은 A로 시작해요.

print("나는 %s살입니다." % 20) # 나는 20살입니다 (%s 로도 정수값 표현 가능)

## 문자열 내에 2개 이상의 값 넣기
print("나는 %s색과 %s색을 좋아해요." % ("파란", "빨간")) # 나는 파란색과 빨간색을 좋아해요.
```

### 두 번째 방법, .format()

**print("문자열 {} 문자열" .format(값))**

```python
# 방법 2

print("나는 {}살입니다.".format(20)) # 나는 20살입니다.
print("나는 {}색과 {}색을 좋아해요.".format("파란", "빨간")) # 나는 파란색과 빨간색을 좋아해요
print("나는 {0}색과 {1}색을 좋아해요.".format("파란", "빨간")) # 나는 파란색과 빨간색을 좋아해요
print("나는 {1}색과 {0}색을 좋아해요.".format("파란", "빨간")) # 나는 빨간색과 파란색을 좋아해요
```

### 세 번째 방법, format(변수=값)

**print("문자열 {변수} 문자열" .format(변수=값))**

문자열 내에 {이름} 과 같이 넣어두고, 마치 변수를 사용하는 것처럼 .format 내에서 이름과 값을 정의해두면, 그 이름에 해당하는 부분에 값을 집어넣게 된다.

```python
# 방법 3

print("나는 {age}살이며, {color}색을 좋아해요.".format(age=20, color="빨간"))
# 나는 20살이며, 빨간색을 좋아해요

print("나는 {age}살이며, {color}색을 좋아해요.".format(color="빨간", age=20))
# 나는 20살이며, 빨간색을 좋아해요 (.format 뒤에 순서를 변경해도 괜찮아요)
```

### 네 번째 방법, f-string

문자열 앞에 f 를 추가해주면, 앞에서 선언된 변수 이름을 그대로 사용할 수 있다. 예제처럼 age 와 color 라는 변수를 선언하고, 문장 안에서 {age}, {color} 와 같이 중괄호로 둘러싼 변수 이름을 적으면 코드가 보다 간결해진다.

```python
# 방법 4 (파이썬 버전 3.6 부터 가능)

age = 20
color = "빨간"
print(f"나는 {age}살이며, {color}색을 좋아해요.") # 나는 20살이며, 빨간색을 좋아해요.
```

## 4-5. 탈출문자

탈출문자는 역슬래시(\)와 함께 어떤 문자를 사용함으로써 문장 내에서 원하는 값을 처리할 수가 있다.

### 문장을 두 줄로 찍기

`\n` 는 문장 내에서 줄바꿈 역할을 수행한다.

```python
print("백문이 불여일견\n백견이 불여일타")
# 백문이 불여일견
# 백문이 불여일타
```

### 따옴표 출력하기

따옴표 앞에 `\` 를 붙여준다.

```python
print("저는 \"나도코딩\"입니다.") # 저는 "나도코딩"입니다.
print("저는 \'나도코딩\'입니다.") # 저는 '나도코딩'입니다.
```

### 폴더나 파일의 경로 출력하기

\를 출력하기 위해서는 \\를 입력한다.

```python
print("C:\\Users\\Nadocoding\\Desktop\\PythonWorkspace>") 
# C:\Users\Nadocoding\Desktop\PythonWorkspace>
```

문자열 앞에 r을 넣는 방법도 있다. 그러면 문자열 내에서 어떤 값이 포함되어 있든지 개의치 않고 그대로 출력한다. 탈출문자가 포함되어 있어도 말이다.

```python
print(r"C:\Users\Nadocoding\Desktop\PythonWorkspace>") # raw string
```

### \r, \b, \t

```python
print("Red Apple\rPine") # PineApple
print("Redd\bApple") # RedApple
print("Red\tApple") # Red     Apple
```

`\r` 은 커서를 맨 앞으로 이동시키는 역할을 한다. "Pine"의 P를 출력하기 이전에 커서를 맨 앞으로, 즉 "Red" 앞으로 이동시켜서 마치 "Red"를 덮어쓰는 효과를 낸다.

`\b` 는 키보드의 백스페이스와 같은 역할을 한다. 즉 앞 글자 하나를 삭제한다.

`\t` 는 키보드의 탭(Tab)과 같이 여러 칸(보통 8칸 단위)을 띄어주는 역할을 한다.

# 5. 자료구조

## 5-1. 리스트

리스트를 사용하는 방법은 대괄호 속에 원하는 값들을 콤마로 구분하여 넣어주면 된다.

```python
subway = ["유재석", "조세호", "박명수"]
print(subway) # ['유재석', '조세호', '박명수']

# 조세호씨가 몇 번째 칸에 타고 있는가?
print(subway.index("조세호")) # 1 (인덱스는 0부터 시작한다는 것, 기억나시죠?)

# 하하씨가 다음 정류장에서 다음 칸에 탐
subway.append("하하")
print(subway) # ['유재석', '조세호', '박명수', '하하']

# 정형돈씨를 유재석 / 조세호 사이에 태움
subway.insert(1, "정형돈") # 인덱스 1 위치에 삽입
print(subway) # ['유재석', '정형돈', '조세호', '박명수', '하하']

# 지하철에 있는 사람을 한 명씩 뒤에서 꺼냄
print(subway.pop()) # 하하 내림
print(subway) # ['유재석', '정형돈', '조세호', '박명수']

print(subway.pop()) # 박명수 내림
print(subway) # ['유재석', '정형돈', '조세호']

print(subway.pop()) # 조세호 내림
print(subway) # ['유재석', '정형돈']

# 같은 이름의 사람이 몇 명 있는지 확인
subway.append("유재석") # 설명을 위해 유재석씨를 맨 뒤에 태울게요
print(subway) # ['유재석', '정형돈', '유재석']
print(subway.count("유재석")) # 유재석씨가 2명이 있네요!
```

`index()` :리스트에서 원하는 값의 인덱스 찾기

`append()` :리스트의 맨 마지막에 데이터 추가하기

`insert(index, value)` :원하는 인덱스 위치에 데이터 추가하기

`pop()` :맨 뒤에 있는 데이터 하나씩 빼기

`count()` :리스트 내에 같은 값이 몇 개 있는지

```python
num_list = [5, 2, 4, 3, 1]

num_list.sort() # 정렬
print(num_list) # [1, 2, 3, 4, 5]

num_list.reverse() # 순서 뒤집기
print(num_list) # [5, 4, 3, 2, 1]

# 모두 지우기
num_list.clear()
print(num_list) # []
```

`sort()` :오름차순 정렬

`reverse()` :리스트 거꾸로 뒤집기

`clear()` :리스트 내의 데이터 모두 지우기

```python
mix_list = ["조세호", 20, True] # 다양한 자료형을 함께 사용할 수 있어요
print(mix_list) # ['조세호', 20, True]

num_list = [5, 2, 4, 3, 1] # num_list 값 다시 정의
num_list.extend(mix_list) # 리스트 확장
print(num_list) # [5, 2, 4, 3, 1, '조세호', 20, True]
```

`extend()` :리스트 두개 합치기

(ex. list1.extend(list2)라면 list1의 뒤쪽에 list2의 값이 합쳐짐)

## 5-2. 사전

사전은 `key`와 `value`가 쌍으로 이루어져 있다. 영한 사전에서는 영어 단어를 key, 단어의 뜻을 value 라고 생각하면 된다.

사전은 중괄호{ }로 둘러싸서 정의하고, key와 value는 콜론(:)으로 구분짓는다. 2개 이상의 데이터는 리스트와 마찬가지로 콤마(,)로 구분한다.

{ key1 : value1, key2 : value2, ... }

```python
# 사전 형태의 사물함인 cabinet 정의
# 유재석에게는 3번 사물함 열쇠를, 김태호에게는 100번 사물함 열쇠를 줌/
cabinet = {3: "유재석", 100: "김태호"}

# 각 사물함이 누구 것인지 확인하자!
print(cabinet[3]) # 유재석 -> key 3 에 해당하는 value
print(cabinet[100]) # 김태호 -> key 100 에 해당하는 value

#대괄호가 아닌 get() 함수 이용
print(cabinet.get(3)) # 유재석 -> key 3 에 해당하는 value
```

### 대괄호와 get() 비교

정의되지 않은 key 전달시

- 대괄호 → 에러, 프로그램 종료
- get() → None 반환, 프로그램 계속 실행

### get() 활용

```python
print(cabinet.get(5, "사용 가능")) # key 에 해당하는 값이 없는 경우 기본 값을 사용
```

### key 값이 사전 자료형에 정의되어 있는지 여부 확인

```python
# 사전 자료형에 값이 있는지 여부 확인
print(3 in cabinet)  # True
print(5 in cabinet)  # False
```

```python
# key 는 정수형이 아닌 문자열도 가능
cabinet = {"A-3": "유재석", "B-100": "김태호"}
print(cabinet["A-3"]) # 유재석
print(cabinet["B-100"]) # 김태호
```

### key, value 업데이트 및 추가

대괄호를 이용하여 값을 설정한다.

`dict[key] = value`

```python
# 업데이트 또는 추가
print(cabinet) # {'A-3': '유재석', 'B-100': '김태호'}
cabinet["A-3"] = "김종국" # key 에 해당하는 값이 있는 경우 업데이트
cabinet["C-20"] = "조세호" # key 에 해당하는 값이 없는 경우 신규 추가
print(cabinet) # {'A-3': '김종국', 'B-100': '김태호', 'C-20': '조세호'}
```

### key, value 데이터 삭제

`del dict[key]`

```python
# 삭제
del cabinet["A-3"] # key "A-3" 에 해당하는 데이터 삭제
print(cabinet) # {'B-100': '김태호', 'C-20': '조세호'}
```

### 모든 key, value 확인하기

`keys()` :key 들만 출력

`values()` :value 들만 출력

`items()` : key, value 쌍으로 출력

```python
# key 들만 출력
print(cabinet.keys()) # dict_keys(['B-100', 'C-20'])

# value 들만 출력
print(cabinet.values()) # dict_values(['김태호', '조세호'])

# key, value 쌍으로 출력
print(cabinet.items()) # dict_items([('B-100', '김태호'), ('C-20', '조세호')])
```

### 사전 내 모든 데이터 삭제하기

`clear()`

```python
# 전체 삭제
cabinet.clear()
print(cabinet) # {}
```

## 5-3. 튜플

튜플은 리스트의 '읽기 전용 버전' 정도로 이해하면 좋다. 튜플은 처음 정의할 때를 제외하고는 **데이터 변경이나 추가, 삭제 등이 불가**하다. 대신 리스트보다는 속도가 빠르다.

튜플은 소괄호를 이용하여 정의한다.

(value1, value2, ...)

```python
menu = ("돈까스", "치즈까스")
print(menu[0]) # 돈까스
print(menu[1]) # 치즈까스

#튜플 형태로 한 줄에 여러 변수의 값 선언하기
(name, age, hobby) = ("김종국", 20, "코딩")
print(name, age, hobby) # 김종국 20 코딩
```

## 5-4. 세트

세트(set, 집합)는 **중복을 허용하지 않으며, 데이터의 순서도 보장하지 않는다.**

수학에서 배우는 것과 동일하게 중괄호를 이용하여 선언한다.

{value1, value2, ...}

또는 set() 함수를 이용하는 방법도 있다. set()함수를 이용할 때는 인자가 1개만 들어갈 수 있는 것에 주의.

```python
mudo = set(["유재석", "박명수"]) # ["유재석", "박명수"]라는 리스트 1개가 인자로 들어감.
mcyoo =  set("유재석")

mudo = set("유재석", "박명수") # TypeError: set expected at most 1 argument, got 2
```

중복을 허용하지 않으므로 같은 값은 여러 번 적어도 딱 한 번만 들어간다.

```python
my_set = {1, 2, 3, 3, 3} # 중복을 허용하지 않으므로 3은 1번만 들어감
print(my_set) # {1, 2, 3}
```

### 교집합

`&` , `intersection()`

```python
java = {"유재석", "김태호", "양세형"} # 자바 개발자 집합
python = set(["유재석", "박명수"]) # 파이썬 개발자 집합

# 교집합 (java 와 python 을 모두 할 수 있는 개발자)
print(java & python) # {'유재석'}
print(java.intersection(python)) # {'유재석'}
```

### 합집합

`|` , `union()`

```python
# 합집합 (java 또는 python 을 할 수 있는 개발자)
print(java | python) # {'박명수', '유재석', '김태호', '양세형'}
print(java.union(python)) # {'박명수', '유재석', '김태호', '양세형'}
```

*주의할 점

집합은 순서를 보장하지 않으므로 집합 내 데이터들의 출력 순서는 실행할 때마다 달라질 수 있다.

### 차집합

`-` , `difference()`

```python
# 차집합 (java 는 할 수 있지만 python 은 할 줄 모르는 개발자)
print(java - python) # {'양세형', '김태호'}
print(java.difference(python)) # {'양세형', '김태호'}
```

### 데이터 추가

`add()`

```python
# python 개발자 추가 (기존 개발자 : 박명수, 유재석)
python.add("김태호")
print(python) # {'박명수', '유재석', '김태호'}
```

### 데이터 삭제

`remove()`

```python
# java 개발자 삭제 (기존 개발자 : 유재석, 김태호, 양세형)
java.remove("김태호")
print(java) # {'유재석', '양세형'}
```

## 5-5. 자료구조의 변경

`type()` :데이터의 형태 확인

```python
menu = {"커피", "우유", "주스"}
print(menu, type(menu)) # menu 의 type 정보 : set

menu = list(menu) # 리스트 형태로 변환
print(menu, type(menu)) # menu 의 type 정보 : list

menu = tuple(menu) # 튜플 형태로 변환
print(menu, type(menu)) # menu 의 type 정보 : tuple

menu = set(menu) # 세트 형태로 변환
print(menu, type(menu)) # menu 의 type 정보 : set
```

## 5-6. random 모듈의 shuffle()과 sample()의 활용

`shuffle()` :단어 뜻 그대로 섞어주는 역할을 하는 함수

`sample()` :리스트 내에서 원하는 갯수의 값을 뽑는 동작을 수행하는 함수(한 번에 원하는 갯수만큼의 번호를 중복 없이 뽑을 수 있다.)

shuffle(list) → list 내의 값들을 무작위 순서로 섞음

sample(list, 1) → list 내의 값 중 1개의 값을 랜덤으로 뽑음

# 6. 제어문

## 6-1. if

"첫 구매이면", "무슨 카드를 쓰면", "학생이면" 등등의 조건에 따라 동작이 달라지는 것, 이것을 프로그래밍에서 `분기` 라고 표현한다.

코드에서 분기는 if를 사용하며 기본적인 형식은 아래와 같다.

if 조건:

실행 명령문

- if 조건문의 끝에는 **콜론(:)**이 붙는다.
- if 조건에 만족할 때 실행해야 할 문장들은 if 위치를 기준으로 공백(스페이스) **4칸씩 들여쓰기**를 해야 한다.
- **elif**는 필요한 만큼 여러 번 사용할 수 있다. 마찬가지로 끝에 콜론(:)을 붙이고, 들여쓰기를 해야 한다.
- if와 elif 들의 모든 조건에 해당하지 않을 때 어떤 명령을 실행하기 위해서는 **else**를 사용한다.

```python
if 조건1:
    실행 명령문1
elif 조건2:
    실행 명령문2
elif 조건3:
    실행 명령문3
else:
    실행 명령문4 # 위 모든 조건들에 해당하지 않을 때 실행
```

`input()` :프로그램 실행 시점에 사용자로부터 어떤 값을 입력받는 용도로 사용한다. 사용자가 값을 입력하고 엔터를 치면 그 값은 항상 "문자열" 형태로 변수에 저장된다. 

- 숫자 3을 입력해도 문자열 "3"으로 인식한다는 점을 주의
- 정수형으로 변환하기 위해서는 input()을 int()로 감싸줄 것. `int(intput())`

## 6-2. for

프로그램에서 분기만큼이나 중요한 것이 바로 **반복**이다. 이 때 필요한 것이 바로 반복문이며, 처음 배워볼 반복문은 for문이다.

for 변수 in 반복대상:

실행 명령문1

실행 명령문2

...

- if와 마찬가지로 for 문장 끝에 **콜론(:)**을 붙이며 반복 대상이 되는 싱행 명령문들은 **들여쓰기**를 해서 구분한다.

## 6-3. while

for 문은 리스트와 같은 반복 대상에서 값을 하나씩 꺼내서 반복 작업을 수행하는 반면, while문은 조건이 만족하는 동안 끝없이 반복한다.

while 조건:

실행 명령문1

실행 명령문2

...

- 조건이 거짓(False)가 되면 while문을 벗어나게 된다.(일반적으로 while 문을 "탈출"한다고 표현함)

## 6-4. continue와 break

`continue` :더 이상 아래 명령들을 실행하지 않고 다음 반복대상으로 넘어갈 때 사용한다.

`break` :즉시 반복문을 탈출하는 데 사용한다.

```python
absent = [2, 5] # 결석한 학생 출석번호
no_book = [7] # 책을 가져오지 않은 학생 출석번호

for student in range(1, 11): # 출석번호 1~10번
    if student in absent: # 결석했으면 책을 읽지 않고 다음 학생으로 넘어가기
        continue
    elif student in no_book: # 책을 가져오지 않았으면 바로 수업 종료 (반복문 탈출)
        print("오늘 수업 여기까지. {0}는 교무실로 따라와".format(student))
        break
    print("{0}, 책을 읽어봐".format(student))
```

```python
1, 책을 읽어봐
3, 책을 읽어봐
4, 책을 읽어봐
6, 책을 읽어봐
오늘 수업 여기까지. 7는 교무실로 따라와
```

## 6-5. 한 줄 for

파이썬에서는 아주 간결하게 한 줄로 된 for 반복문을 이용할 수 있다. 반복 대상 항목을 하나씩 순회하면서 변수에 저장하고 그 변수를 사용자가 원하는 동작을 수행하는 방식이다.

[변수로 어떤 동작 for 변수 in 반복대상]

```python
students = [1, 2, 3, 4, 5]
print(students) # [1, 2, 3, 4, 5]

# 한 줄 for 를 이용하여 각 항목에 100 을 더함
students = [i + 100 for i in students]
print(students) # [101, 102, 103, 104, 105]
```

students = [i + 100 for i in students]

→ 반복대상인 students 리스트에서 하나씩 값을 가져와서 i 라는 변수에 저장하고, 그 변수를 활용하여 i + 100 이라는 명령을 실행한 값들을 새로운 리스트로 만들어서 students에 집어넣으라는 의미.

→ 정리하면, 반복 대상 항목의 값들에 대해서 각각 어떤 동작을 수행하고, 수행한 결과들을 모아서 새로운 리스트로 만드는 것이다.

*주의할 점

이 때 사용된 i 는 사용자가 임의로 사용한 이름이며, 다른 이름을 사용해도 된다. 다만 그 이름이 "변수" 위치와 "변수로 어떤 동작" 위치에 동일하게 사용되어야 한다는 점을 주의할 것.

```python
# (예)

students = [x + 100 for x in students]

students = [name + 100 for name in students]
```

### 이름의 길이 정보를 가져오는 리스트로 변형

```python
students = ["Iron man", "Thor", "I am groot"]
print(students) # ["Iron man", "Thor", "I am groot"]

# 한 줄 for 를 이용하여 각 이름의 길이 정보로 변환
students = [len(i) for i in students]
print(students) # [8, 4, 10]
```

### 이름을 모두 대문자로 변형

```python
students = ["Iron man", "Thor", "I am groot"]
print(students) # ["Iron man", "Thor", "I am groot"]

# 한 줄 for 를 이용하여 각 이름을 대문자로 변경
students = [i.upper() for i in students]
print(students) # ['IRON MAN', 'THOR', 'I AM GROOT']
```

# 7. 함수
### 함수 정의

print(), len(), append(), pop() 이런 것들이 모두 함수이며, **def** 라는 글자와 함께 **함수 이름**, 그리고 **괄호()** 로 구성된다. 그리고 함수의 동작을 정의하는 부분도 필요하므로 뒤에 **콜론(:)** 을 적어준다.

def 함수이름():

실행 명령문1

실행 명령문2

....

### 함수 호출

함수를 사용할 때는 함수 이름과 괄호()를 함계 적어주면 되고, 이 때 "함수를 호출한다"라고 표현한다.

```python
def open_account(): # 함수 정의
    print("새로운 계좌가 생성되었습니다.")

open_account() # 앞에서 정의된 open_account() 함수 호출
```

### 함수명 짓기

- 함수의 이름은 그 함수의 동작을 대표하는 것으로 짓는 게 좋다.
- 문자로 시작하며 각 단어들(open, account) 을 밑줄(_) 로 구분하는 형태라면 대부분 사용 가능하다.
- 보통 변수는 명사, 함수는 동사를 이용한다.

(예)

변수 : account_number → 계좌 번호 (명사)

함수 : open_account() → 계좌를 개설하다 (동사)

## 7-2. 전달값과 반환값

함수에는 `전달값`, `동작`, `반환값`이라는 3가지 요소가 있다. 전달값과 반환값은 옵션이기 때문에 이 둘은 있는 함수도 없는 함수도 있다.

함수 이름 옆의 괄호() 에는 필요한 갯수 만큼의 전달값이 들어가며, 함수 내에서는 이 전달값들을 활용한 어떤 명령을 수행하고 나서 맨 아래에 있는 return 을 통해서 값을 반환해준다. 전달값과 마찬가지로 반환값 또한 2개 이상이 될 수도 있다.

def 함수이름(전달값, 전달값2, ...):

실행 명령문1

실행 명령문2

...

return 반환값1, 반환값2

```python
def deposit(balance, money): # 입금
    print("입금이 완료되었습니다. 잔액은 {0} 원입니다.".format(balance + money))
    return balance + money # 입금 후 잔액 정보 반환
    
balance = 0 # 최초 잔액
balance = deposit(balance, 1000) # 1000원 입금
print(balance) # 현재 잔액
```

 이 때, 1000원을입금하는 부분인 deposit(balance, 1000)에서의 balance는 바로 윗줄에 선언된 잔액 정보를 가지는 변수이며, 1000이 입금액이 된다. 즉, deposit 함수를 호출하는데 0과 1000이라는 2개의 값을 전달하는 셈이 된다.

함수를 정의할 때 전달값을 받기 위해 사용되는 balance, money 와 같은 변수를 `매개변수(parameter)` 라고 부르기도 합니다.

그리고 함수 정의부분에 있는 deposit(balance, money)에서의 balance는 함수 내에서 사용할 변수 이름이 되는데, 호출할 때 사용된 balance와 똑같은 이름이 사용되기는 했지만 둘은 사실 같은 변수는 아니다. 그저 처음 전달받은 값인 0을 저장하는 새로운 변수일 뿐이다.

함수 내의 동작이 완료되고 나서 마지막으로 return balance + money 를 통해 값을 반환해주는데, 이렇게 반환해주는값은 함수 밖에 정의된 balance 함수에 저장된다. 마치 변수에 어떤 값을 저장하는 것처럼, 함수를 호출하고 나서 반환해주는 값을 저장하게 되는 것이다.

```python
balance = 0 # balance 변수에 0 이라는 값을 저장
balance = deposit(balance, 1000) # balance 변수에 deposit() 함수의 반환값을 저장
```

만약 앞에 balance = 란 부분이 없다면?

```python
deposit(balance, 1000)
```

deposit(balance, 1000함수는 어떤 값을 반환해주기는 하는데 아무 변수도 지정하지 않았으므로 그 값은 어디에서도 사용할 수 없게 된다. 그렇기 때문에 반환값이 있는 함수를 이용하며 반환값을 사용하고자 할 때에는 반드시 값을 반환 받을 변수를 명시해야 한다.

- 함수 내에서 return 부분이 실행되고 나면 값을 반환함과 동시에 함수는 탈출하게 된다.
- 그러므로 return 밑에 어떤 코드가 있다면 이 부분은 실행되지 않는다는 점 주의!
- 마치 반복문을 탈출하게 해주는 break 와 비슷하다고 이해하면 된다.

### 변수 2개에 반환값 2개 각각 저장하기

```python
def withdraw_night(balance, money): # 저녁에 출금
    commission = 100 # 출금 수수료 100원
    return commission, balance - money - commission # 튜플 형식으로 반환
    
balance = 0 # 최초 잔액
balance = deposit(balance, 1000) # 1000원 입금

# 저녁에 출금 시도
commission, balance = withdraw_night(balance, 500)
print("수수료 {0} 원이며, 잔액은 {1} 원입니다.".format(commission, balance))
```

return 부분을 살펴보면 수수료를 저장하고 있는 commission 과 출금 후 잔액인 balance - money - commission (기존 잔액에서 출금액과 수수료를 뺀 금액) 을 콤마로 구분하여 함께 적었다. 바로 튜플 형태인데, 콤마로 구분하여 2개 이상의 값을 적으면 함수를 호출하는 쪽에서도 콤마로 구분된 여러 개의 변수에 값을 한 번에 저장할 수 있게 된다. 예제에서는 좌항의 commission 과 balance 에 각각 수수료와 잔액 정보를 저장하고 있다.

```python
commission, balance = withdraw_night(balance, 500) # 튜플 형식으로 반환된 2개의 값을 각 변수에 저
```

## 7-3. 기본값

함수를 호출할 때 기본으로 사용할 값을 정의해줄 수 있다. 모든 전달값에 대해서 일일이 적지 않아도 되는 이점이 있다.

```python
def profile(name, age=17, main_lang="파이썬"): # 전달값을 따로 받지 않을때 기본으로 사용할 값
    print("이름 : {0}\t나이 : {1}\t주 사용 언어 : {2}".format(name, age, main_lang))
        
profile("유재석")
profile("김태호")
```

물론 기본값이 있다고 해도 다음과 같이 필요한 전달값을 포함하면 기본값을 정의하지 않았을 때와 동일하게 사용할수 있다.

```python
profile("유재석") # age, main_lang 을 기본값으로 사용
profile("유재석", 20) # main_lang 을 기본값으로 사용
profile("유재석", 20, "파이썬") # 기본값 사용하지 않음
```

## 7-4. 키워드 인자

함수를 호출하는 방법 중에 키워드 인자를 이ㅛㅇ하는 방법도 있다.

```python
def profile(name, age, main_lang): # 키워드 인자 : name, age, main_lang
    print(name, age, main_lang)

# profile("유재석", 20, "파이썬")
# profile("김태호", 25, "자바")

profile(name="유재석", main_lang="파이썬", age=20)
profile(main_lang="자바", age=25, name="김태호")
```

함수를 호출하는 곳에서의 전달값(인자)의 순서와 상관없이 순서대로 값들이 잘 출력된다.

```python
# 출력
유재석 20 파이썬
김태호 25 자바
```

키워드 인자는 보통 어떤 함수에 전달값들이 많고 기본값들이 잘 정의되어 있을 때, 대부분 기본값을 쓰고 필요한 부분만 콕 찍어서 값을 전달하고자 하는 경우에 유용하다. 무엇보다 순서에 구애받지 않으므로 함수에서 사용 가능한 키워드의 종류만 알고 있따면 아주 편리하게 사용 가능하다는 장점이 있다.

*주의할 점

함수를 호출할 때 일반적인 전달값과 키워드 인자를 함께 사용하는 경우에는 반드시 일반 전달값들을 순서대로 먼저 적고 나서 키워드 인자들을 적어야 한다. 그리고 키워드 인자에 오타가 있는 경우 에러가 발생할 수 있으니 주의!

```python
#(예)

profile("유재석", age=20, main_lang="파이썬") # (O) 올바른 함수 호출 방법 (일반 전달값을 먼저 작성)

profile(name="김태호", 25, "파이썬") # (X) 잘못된 함수 호출 방법 (키워드 인자 먼저 작성 후 일반 전달값 작성)
```

## 7-5. 가변인자

가변인자란 말 그대로 변할 수 있는 인자를 의미한다.

def 함수이름(전달값1, 전달값2, ..., `*가변인자`):

실행 명령문1

실행 명령문2

...

return 반환값

가변인자는 앞에 `*` 표시를 하나 추가해주면 된다.

```python
def profile(name, age, *language): # 언어 정보를 전달하고 싶은 갯수 만큼 전달 가능    
    print("이름 : {0}\t나이 : {1}\t".format(name, age), end=" ")
    
    # print(type(language)) # tuple
    for lang in language:
        print(lang, end=" ") # 언어들을 모두 한 줄에 표시
    print() # 줄바꿈 목적
```

가변인자인 language의 타입을 확인해보면 튜플임을 알 수 있다. 그렇기 때문에 for문을 사용하면 가변인자로 전달받은 값들을 하나씩 반복하면서 사용할 수 있다. 각 언어들을 한 줄에 표시하기 위해 이번에도 end=""를 추가했고, 모든 언어 정보를 출력하고 나면 줄바꿈을 해주기 위해 비어 있는 print()를 적어준다.

```python
profile("유재석", 20, "Python", "Java", "C", "C++", "C#", "JavaScript") # JavaScript 추가
profile("김태호", 25, "Kotlin", "Swift")
```

```python
# 이름 : 유재석   나이 : 20        Python Java C C++ C# JavaScript
# 이름 : 김태호   나이 : 25        Kotlin Swift
```

## 7-6. 지역변수와 전역변수

`지역 변수` :함수 내에서만 쓸 수 있는 변수

`전역 변수` :모든 곳에서 쓸 수 있는 변수

`global` :함수 내에서 전역변수를 사용하기 위한 키워드, 전역 공간에 선언된 변수를 그대로 사용하며 그 값은 직접 변경할 수도 있다.

```python
gun = 10

def checkpoint(soldiers):
    global gun # 전역공간에 있는 gun 이라는 변수를 사용
    gun = gun - soldiers
    print("[함수 내] 남은 총 : {0}".format(gun))

print("전체 총 : {0}".format(gun))
checkpoint(2)
print("남은 총 : {0}".format(gun))
```

```python
# 실행결과
전체 총 : 10
[함수 내] 남은 총 : 8
남은 총 : 8
```

### 전역변수가 없는 버전으로 만들기

전달값과 반환값을 적절히 활용하여 만들자.

```python
gun = 10

def checkpoint_ret(gun, soldiers): # 전체 총 수와 군인 수를 전달받음
    gun = gun - soldiers # 전달받은 gun 을 사용
    print("[함수 내] 남은 총 : {0}".format(gun))
    return gun

print("전체 총 : {0}".format(gun))
gun = checkpoint_ret(gun, 2) # gun 값을 함수에 전달
print("남은 총 : {0}".format(gun))
```

함수를 정의할 때 가급적 외부 상황은 몰라도 되도록 전달받은 값만 이용하게끔 작성하면 보다 간결하면서도 함수의 역할에 충실할 수 있다.
# 8. 입출력
## 8-1. 표준입출력

```python
print("Python", "Java")

print("Python" + "Java")
```

첫 번째 문장은 `콤마(,)` 로 문자열들을 구분하였고, 두 번째 문장은 `더하기(+)` 기호로 문자열들을 합쳤다.

```python
# 실행 결과
Python Java

PythonJava
```

`sep` :문자열들을 구분하는 방법을 사용자가 직접 정의할 수 있도록 해주는 기능(분리 기호를 의미하는 seperator의 줄임말)

```python
print("Python", "Java", sep=",") # 값들을 콤마(,)로 구분
print("Python", "Java", "JavaScript", sep=" vs ") # 값들을 " vs " 로 구분
```

```python
# 실행 결과
Python,Java
Python vs Java vs JavaScript
```

print()는 기본적으로 문장이 끝날 때마다 줄바꿈을 하기 때문에 연속적으로 2개 이상의 print()를 이용하면 각각의 줄에 내용이 출력된다. 하지만 이를 한 줄에 모두 엮어서 출력하려면 `end=" "`와 같이 하면 된다.

```python
print("Python", "Java", sep=",", end="?")
print("무엇이 더 재밌을까요?")
```

```python
# 실행 결과
Python,Java?무엇이 더 재밌을까요?

# end= 를 적지 않았을 때의 결과
Python,Java

무엇이 더 재밌을까요?
```

### 표준 출력과 표준 에러

```python
import sys # sys 모듈을 가져와서 사용하겠다는 의미
print("Python", "Java", files=sys.stdout) # 표준 출력
print("Python", "Java", files=sys.stderr) # 표준 에러
```

```python
# 출력 결과
Python Java
Python Java
```

file= 에 `sys.stdout (Standard Output, 표준 출력)` 와 `sys.stderr (Standard Error, 표준 에러)` 를 각각 넣었는데, 출력결과는 크게 달라보이지 않는다. 보다 큰 규모의 파이썬 프로젝트를 진행하게 되면 필요해질텐데, `stdout` 과 `stderr` 은 사용하는 용도가 조금 다르다.

보통 프로그램 수행 과정에서 몇 시에 어떤 작업을 어떤 식으로 수행하고 있으며 그 결과는 어떠한지 등의 정보를 가지는 로그를 남길 때 `stdout` 은 일반적인 내용을, `stderr` 는 에러 발생 시 관련 내용을 출력하기 위해 사용할 수 있다. 이렇게 구분지어주면 프로그램이 의도치 않은 동작을 하는 경우에 에러 로그만 확인하면 보다 빠르게 상황 파악 및 조치가 가능해진다.

파이썬 기본편을 공부하는 시점에서는 이런 게 있구나 정도로만 이해하고 넘어가도 좋다.

### 왼쪽 정렬과 오른쪽 정렬

`ljust()` : l은 왼쪽(left)을 의미하며 함께 전달하는 숫자값 만큼 미리 공간을 확보하고 그 공간에 왼쪽 정렬을 한다.

`rjust()` : r은 오른쪽(right)을 의미하며, 오른쪽 정렬을 한다.

```python
scores = {"수학":0, "영어":50, "코딩":100}

for subject, score in scores.items():
    print(subject.ljust(8), str(score).rjust(4), sep=":")
```

```python
# 실행 결과
수학      :   0
영어      :  50
코딩      : 100
```

`zfile()` : 함께 전달해주는 숫자만큼의 공간을 확보하고 그 공간을 zero로, 즉 0으로 채워주는(fill) 동작을 한다.

```python
for num in range(1, 21): # 1~20 까지의 숫자
    print("대기번호 : " + str(num).zfill(3))
```

```python
# 실행 결과
대기번호 : 001
대기번호 : 002
대기번호 : 003

... 생략 ...

대기번호 : 018
대기번호 : 019
대기번호 : 020
```

### 표준 입력

input() 을 통해 입력받는 모든 값은 항상 **문자열** 형태로 저장되기 때문에 만약 10 과 같은 정수를 입력받고 이 값을 실제로 계산 목적으로 사용하려면 반드시 **int(input())** 와 같이 형을 바꿔줘야 한다.

## 8-2. 다양한 출력포맷

### 오른쪽/왼쪽 정렬 및 빈 자리 채우기

```python
print("{0}".format(500)) # {0} 위치에 500 값 출력
print("{0: >10}".format(500)) # 빈 자리는 비워두기, 우측 정렬, 10 칸의 공간 확보

print("{0: >+10}".format(500)) # 빈 자리는 비워두기, 우측 정렬, + 기호, 10 칸의 공간 확보
print("{0: >+10}".format(-500))

print("{0:_<10}".format(500)) # 빈 자리는 _ 로, 좌측 정렬, 10 칸의 공간 확보
```

```python
# 실행 결과
'''
500
       500
      +500
      -500
500_______
'''
```

### 1,000단위로 콤마 찍기

```python
print("{0:,}".format(100000000000)) # 3자리 마다 콤마 찍어주기
print("{0:+,}".format(100000000000)) # + 기호, 3자리 마다 콤마 찍어주기
print("{0:+,}".format(-100000000000))
```

```python
# 실행 결과
'''
100,000,000,000
+100,000,000,000
-100,000,000,000
'''
```

```python
# 빈 자리는 ^ 로, 좌측 정렬, + 기호, 30 칸의 공간 확보, 3자리 마다 콤마 찍어주기
print("{0:^<+30,}".format(100000000000))
# +100,000,000,000^^^^^^^^^^^^^^
```

### 소수점 출력하기

f는 실수형 자료(float)를 의미하는데 점(.)과 숫자(n)를 함께 적으면 소수점 n번째 자리까지 출력 해준다. 셋째자리에서 반올림하여 둘째자리까지 출력하려면 .2f라고 적으면 된다.

```python
print("{0:f}".format(5/3)) # 실수 값 출력
# 1.666667
print("{0:.2f}".format(5/3) # 소수점 둘째자리까지 출력
#1.67
```

지금까지 공부한 출력 포맷은 다음과 같은 순서로 { } 내에 사용자가 필요한 부분만 명시하는 방식으로 포맷을 정의할 수 있다.

{인덱스:[[빈자리채우기]정렬][기호][확보공간][콤마][.자릿수][타입]}

## 8-3. 파일입출력

프로그래밍에서 파일을 다룰 때는 일반적으로

1. **파일을 열고**
2. **파일에 어떤 내용을 쓰거나 읽고**
3. **파일을 닫는**

순서로 진행한다.

파일을 열기 위해서는 `open()` 이라는 함수를 이용하면 된다.

open("파일명", "열기 모드", encoding="인코딩")

2번째로 전달하는 **"열기 모드"** 에는 `읽기(read, "r")`, `쓰기(write, "w")`, `이어쓰기(append, "a")` 가 있다. 읽기는 말 그대로 이미 어떤 내용을 담고 있는 파일을 읽어오기 위한 모드이며, 파일에 어떤 내용을 쓰기 위해서는 쓰기나 이어쓰기 모드를 사용한다. 이 때 동일한 이름의 파일이 있는 경우 쓰기 모드는 그 파일을 덮어쓰게 되므로 기존 내용은 다 삭제가 되며, 이어쓰기 모드는 그 파일의 내용 맨 밑에 이어서 쓴다는 차이점이 있다.

`encoding`은 파일 내용으로 쓰는 언어와 관련된 것인데 일반적으로 **"utf-8"** 로 설정 해주면 한글을 포함한 내용을 다룰 때에도 문제가 없다.

```python
score_file = open("score.txt", "w", encoding="utf8") # score.txt 파일을 쓰기("w") 모드로 열기
print("수학 : 0", file=score_file) # score.txt 파일에 내용 쓰기
print("영어 : 50", file=score_file) # score.txt 파일에 내용 쓰기
score_file.close() # score.txt 파일 닫기
```

코드 마지막 줄에 close() 함수를 호출하는데, 파일을 열고 나면 반드시 닫아주어야 한다. 파일을 닫지 않으면 소스코드의 다른 위치에서 동일한 파일에 접근하려고 할 때 파일에 따라 문제가 발생할 수도 있다.

```python
score_file = open("score.txt", "a", encoding="utf8") # score.txt 파일을 쓰기("a") 모드로 열기
score_file.write("과학 : 80")
score_file.write("\n코딩 : 100") # write 는 줄바꿈 안해주기 때문에 탈출문자(\n)로 줄바꿈 추가
score_file.close()v
```

파일 변수에서 제공하는 `write()` 함수는 print() 와는 다르게 자동으로 줄바꿈을 해주지 않기 때문에 탈출문자(\n)를 통해서 줄바꿈을 추가한다.

```python
score_file = open("score.txt", "r", encoding="utf8") # score.txt 파일을 읽기("r") 모드로 열기
print(score_file.read()) # 파일 전체 읽어오기
score_file.close()
```

파일은 한 번에 모두 읽어올 수도 있지만 한 줄 한 줄 끊어서 읽어올 수도 있다. `readline()` 함수를 이용하면 한 줄 단위로 불러온다.

```python
score_file = open("score.txt", "r", encoding="utf8")
print(score_file.readline(), end="") # 줄별로 읽기. 한 줄 읽고 커서는 다음 줄로 이동
print(score_file.readline(), end="") # 줄바꿈 중복을 방지하기 위해 end="" 처리
print(score_file.readline(), end="")
print(score_file.readline(), end="")
score_file.close()
```

현재 파일에 쓰여진 각 문장은 끝에 줄바꿈을 포함하고 있기 때문에 print() 자체의 줄바꿈과 중복으로 실행되는 증상을 막기 위해서 각 문장마다 end=""로 처리했다.

```python
score_file = open("score.txt", "r", encoding="utf8")

while True:
    line = score_file.readline()
    if not line: # 더 이상 읽어올 내용이 없으면?
        break # 반복문 탈출
    print(line, end="") # 읽어온 줄 출력. 줄바꿈 중복을 방지하기 위해 end="" 처리
    
score_file.close()
```

대부분의 경우 파일이 총 몇 줄로 구성되었는지는 열어보기 전까지는 알 수 없다. 이 때는 while 반복문을 사용하여 읽으려는 줄이 있는 동안 계속 반복하여 읽어들이도록 할 수 있다. 더 이상 읽으려는 줄이 없을 때 반복문을 탈출하도록 하는 것이다.

while 반복문의 조건을 True 로 설정하였기 때문에 계속하여 반복 수행하게 되며, 매 단계마다 line 이라는 변수에 한 줄씩 읽어와서 내용이 있는지 확인하고 있으면 출력, 더 이상 읽어올 내용이 없으면 반복문이 탈출하게 되는 원리다.

```python
score_file = open("score.txt", "r", encoding="utf8")

lines = score_file.readlines() # 모든 줄을 읽어와서 list 형태로 저장
for line in lines:
    print(line, end="") # 읽어온 줄 출력. 줄바꿈 중복을 방지하기 위해 end="" 처리
    
score_file.close()
```

`readlines()` 는 파일 내 모든 줄을 읽어오는 함수를 이용하여 while 대신 for 문을 이용하여보다 수월하게 리스트 데이터를 순차적으로 읽어오도록 작성할 수 있다.

## 8-4. pickle

프로그램의 실행이 종료되고 나면 이 모든 데이터는 흔적도 없이 사라지게 된다. 그런데 만약 이 리스트 데이터를 또 사용해야 한다면 어떻게 할 수 있을까? 프로그램은 실행이 끝나버리면 모든 데이터가 사라지므로 끝나기 전에 어딘가 저장을 해야한다. 이 때 사용할 수 있는 것이 바로 `pickle` 이다. 

`pickle` : 프로그램에서 사용하고 있는 데이터를 파일 형태로 저장하거나 불러올 수 있게 해주는 모듈

먼저 pickle을 이용하여 데이터를 파일로 저장을 할 때는 `dump()`라는 함수를 사용한다. 첫 번째 전달값으로 **저장할 데이터**를, 두 번째 전달값으로는 **데이터를 저장할 파일**을 적어준다.

dump(data, dest_file)

### 예제

어떤 사람의 프로필 데이터를 만들고 저장하는 예제를 들어보자.

먼저 pickle 모듈을 가져다 쓰기 위해 import 를 한다.

이어서 파일을 하나 열 텐데 파일 이름은 "profile.pickle" 로 하고 쓰기 모드인 "w" 로 하는데, pickle 을 이용해서 저장되는 파일은 텍스트(text)가 아닌 **바이너리(binary) 형태**이다. 일반적인 한글, 영어, 숫자 등의 내용을 담고 있는게 텍스트 파일이라면 .jpg, .png 와 같은 이미지나 .mp3 와 같은 음악, 또는 .exe 와 같은 실행 파일 등이 바이너리 파일이다.

pickle 로 저장하는 파일 또한 바이너리 파일이기 때문에 open() 함수를 이용할 때 "w" 뒤에 "b" 를 붙여서 "**wb**" 라고 해야 올바르게 저장이 된다. 또한 데이터 내에 한글이 포함되어 있다 하더라도 별도의 encoding 은 지정할 필요가 없다.

```python
import pickle # pickle 모듈 가져다 쓰기

profile_file = open("profile.pickle", "wb") # 바이너리(binary) 형태로 저장
profile = {"이름":"박명수", "나이":30, "취미":["축구", "골프", "코딩"]}
print(profile)

pickle.dump(profile, profile_file) # profile 데이터를 file 에 저장
profile_file.close()
```

코드를 실행하면 profile 에 들어있는 데이터가 출력되고 워크스페이스 내에 profile.pickle 이라는 파일이 생긴 것을 확인할 수 있다. 이 파일은 바이너리 형태로 저장되었기 때문에 비주얼 스튜디오 코드나 파일 에디터 프로그램에서 열어도 그 내용을 올바르게 확인할 수는 없다.

사용하려는 모듈과 동일한 이름을 생성하면 import 시에 동일한 경로에 있는 파일을 먼저 인식하기 때문에 AttributeError가 난다.

이번에는 데이터가 정말 잘 저장되었는지 확인하기 위해 앞에서 만든 파일을 다시 불러올텐데, 이 때는 `load()` 함수를 이용하고 전달값으로는 파일을 작성하면 됩니다.

load(src_file)

먼저 파일을 열텐데 저장할 때와 마찬가지로 읽기 모드(r)에서도 **바이너리 파일**이기 때문에 "b" 를 붙여서 "**rb**" 라고 해야한다. load() 함수를 통해서 이 파일을 전달한다. 그러면 좌항에 있는 profile 변수에 파일에서 불러온 데이터를 그대로 저장하게 된다. 잘 불러왔는지 출력하고 나서 이번에도 close() 함수를 통해 파일을 닫아준다.

```python
profile_file = open("profile.pickle", "rb") # 읽을 때에도 바이너리(binary) 명시
profile = pickle.load(profile_file) # file 에 있는 정보를 불러와서 profile 에 저장

print(profile)
profile_file.close()
```

코드를 실행해보면 저장할 때와 동일한 데이터를 그대로 불러온 것을 확인할 수 있다.

```python
# 실행 결과
{'이름': '박명수', '나이': 30, '취미': ['축구', '골프', '코딩']}
```

## 8-5. with

파이썬에서는 `with` 란 것이 있는데, 이를 이용하면 파일을 열고 나서 close() 를 호출하지 않아도 자동으로 닫아주는 역할을 해준다.

with 작업 as 변수명:

실행 명령문1

실행 명령문2

...

with 뒤에 따라오는 작업이 바로 파일을 여는 opee() 함수가 들어가는 부분이다. open() 을 통해 열린 파일은 as 뒤에 있는 변수명으로 접근할 수 있다. if, for, while, def 와 같이 문장 끝에 콜론(:) 을 붙여주고, with 구문 내에서 실행할 명령문들은 반드시 들여쓰기를 해야 한다. 그리고 with 구문을 벗어나면 변수명은 사용할 수 없게 된다.

### 예제

```python
import pickle

with open("profile.pickle", "rb") as profile_file:
    print(pickle.load(profile_file))
```

실행해보면 데이터가 잘 출력된 것을 확인할 수 있다.

```python
with open("study.txt", "w", encoding="utf8") as study_file:
    study_file.write("파이썬을 열심히 공부하고 있어요")
```

```python
with open("study.txt", "r", encoding="utf-8") as study_file:
    print(study_file.read())
```

with 를 사용하면 파일을 읽고 쓰는 코드도 간결해지며, 매번 close() 함수를 호출해야 하는 부담도 줄어들기 때문에 보다 수월하게 파일 관련 작업을 할 수 있다.

# 9. 클래스

## 9-1. 클래스

```python
# 마린 : 공격 유닛, 군인. 총을 쏠 수 있음
name = "마린" # 유닛의 이름
hp = 40 # 유닛의 체력
damage = 5 # 유닛의 공격력

print("{} 유닛이 생성되었습니다.".format(name))
print("체력 {0}, 공격력 {1}\n".format(hp, damage))

# 탱크 : 공격 유닛, 탱크. 포를 쏠 수 있는데, 일반 모드 / 시즈 모드
tank_name = "탱크"
tank_hp = 150
tank_damage = 35

print("{} 유닛이 생성되었습니다.".format(tank_name))
print("체력 {0}, 공격력 {1}\n".format(tank_hp, tank_damage))

# 탱크2 새로 추가
tank2_name = "탱크"
tank2_hp = 150
tank2_damage = 35

print("{} 유닛이 생성되었습니다.".format(tank2_name))
print("체력 {0}, 공격력 {1}\n".format(tank2_hp, tank2_damage))

# 공격 함수
def attack(name, location, damage):
	print("{0} : {1} 방향으로 적군을 공격 합니다. [공격력 {2}]".format(name, location, damage))

attack(name, "1시" , damage) # 마린 공격 명령
attack(tank_name, "1시" , tank_damage) # 탱크 공격 명령
```

실제 게임에서는 서로 다른 종류의 유닛들이 최소 수십에서 많게는 수백개가 존재한다. 유닛마다 이렇게 서로 다른 정보(이름, 체력, 공격력 등) 를 관리하기에는 무리일 것이다.

이 때 필요한 것이 바로 `클래스`. 클래스는 보통 붕어빵 기계의 틀에 비유를 하는데, 붕어빵을 만들 때 틀에다가 재료를 넣고 불에 구우면 똑같은 모양의 붕어빵을 만들 수 있다. 틀은 하나인데 붕어빵은 계속해서 만들 수 있는 것! 클래스도 이러한 하나의 틀이라고 생각하시면 되는데 보통 **서로 연관이 있는 변수와 함수의 집합**으로 이루어진다.

기본적인 클래스

- class 뒤에 클래스 이름을 정의하고 콜론(:)을 적는다.
- 그 다음줄부터는 들여쓰기를 하고 필요한 메소드를 정의한다.
- 클래스 내에서 정의되는 함수를 `메소드` 라고 하는데, 앞에서 배운 함수와 거의 동일하다.
- 다만 첫 번째 전달값 위치에는 **self** 라는 것이 적힌다는 것을 주의할 것.
- 메소드 내의 각 실행명령문들은 또 한 번 들여쓰기를 통해서 정의한다.

```python
class 클래스명:
	def 메소드1(self, 전달값1, 전달값2, ...):
		실행 명령문1
		실행 명령문2
		...
	def 메소드2(self, 전달값1, 전달값2, ...):
		실행 명령문1
		실행 명령문2
		...
```

### 예제

Unit 이라는 이름으로 클래스를 정의하고 메소드를 하나 만드는데 이름은 **init** (언더바를 앞뒤로 각각 2개씩 적어주세요) 으로 한다. 그리고 처음에는 일단 self 를 적고 뒤에는 이름, 체력, 데미지에 해당하는 전달값들을 적는다. 메소드 내에서는 다음과 같은 형태로 변수를 정의할 수 있다.

self.변수명 = 값

이렇게 정의된 변수를 `멤버변수` 라고 하는데, **클래스 내에서 사용할 수 있는 변수** 정도로 이해하면 된다.

```python
class Unit:
	def __init__(self, name, hp, damage):
			self.name = name # 멤버변수 name에 전달값 name wjwkd
			self.hp = hp
			self.damage = damage
			print("{0} 유닛이 생성되었습니다.".format(self.name))
			print("체력 {0}, 공격력{1}".format(self.hp, self.damage))
```

그런데 클래스도 함수와 마찬가지로 정의만 해서는 아무 동작을 하지 않는다. 클래스 밖에서 유닛을 직접 만들어보자. 이 때 **클래스를 통해서 만들어지는 것**을 `객체(Object)`라고 표현하며, 이 객체는 클래스의 `인스턴스(Instance)`가 된다.

```python
marine1 = Unit("마린", 40, 5) # 마린1 생성. 전달값으로 name, hp, damage 를 전달
marine2 = Unit("마린", 40, 5) # 마린2 생성
tank = Unit("탱크", 150, 35) # 탱크 생성
```

Unit 클래스를 통해 만들어진 마린과 탱크를 `객체`라고 하며, 이 때 "마린과 탱크는 Unit 클래스의 `인스턴스`다" 라고 한다.

클래스를 통해 객체를 생성할 때는 아래와 같은 형식으로 한다.

변수명 = 클래스명(전달값1, 전달값2, ...) # 전달값은 클래스의 **init**() 에 정의된 부분 중 self 를 제외한 값

`클래스` : 서로 관련이 있는 변수(멤버변수)와 함수(메소드)들의 집합

클래스 내에는 여러 개의 메소드를 정의할 수 있는데 

- 각 메소드의 첫 번째 전달값 위치에는 **self** 를 적어준다.
- **init**() 메소드를 통해 기본적으로 **필요한 전달값들을 전달받고**,
- **self.** 을 통해 클래스의 **멤버 변수를 정의**합니다.

## 9-2. __init__

클래스에는 **init**() 메소드가 있다. 이를 `생성자(Constructor)` 라고 부르는데요, 사용자가 따로 호출하지 않아도 클래스 **객체를 생성할 때 자동으로 호출이 되는 부분**이다. **객체를 생성할 때는 이 생성자의 전달값에 해당하는 갯수만큼 값을 던져줘야 한다.** (단, self 부분은 제외)

## 9-3. 멤버변수

`멤버변수` :클래스 내에서 정의된 변수를 의미하며 self. 와 함께 사용할 수 있다.

### 객체를 통해 접근하여 멤버변수 정보 출력하기

클래스 생성자나 메소드가 아닌 곳에서 멤버변수 정보를 출력해보자. 클래스 내에서는 self. 과 같이 멤버변수에 접근할 수 있었는데 객체를 통해 접근할 때에는 **객체 이름 뒤에 점(.) 을 찍고 멤버변수 이름을 적으면 된다.**

```python
# 레이스 : 공중 유닛, 비행기. 클로킹 (상대방에게 보이지 않음)
wraith1 = Unit("레이스", 80, 5) # 체력 80, 공격력 5
print("유닛 이름 : {0}, 공격력 : {1}".format(wraith1.name, wraith1.damage)) # 멤버변수 접근
```

객체 이름이 wraith1 이므로 이 객체가 가지는 멤버변수는 wraith1.name, wraith1.damage 와 같이 접근하여 값을 출력한다.

### 클래스 외부에서 멤버 변수 정의하기

```python
# 마인드 컨트롤 : 상대방 유닛을 내 것으로 만드는 것 (빼앗음)
wraith2 = Unit("빼앗은 레이스", 80, 5)
wraith2.cloaking = True # 빼앗은 레이스만을 위한 특별한 멤버변수 정의

if wraith2.cloaking == True: # 클로킹 상태라면?
    print("{0}는 현재 클로킹 상태입니다.".format(wraith2.name))

# 에러 발생
# if wraith1.cloaking == True: # 우리가 만든 레이스 클로킹 여부
#     print("{0}는 현재 클로킹 상태입니다.".format(wraith1.name))
```

Unit 클래스에는 처음과 변함 없이 name, hp, damage 라는 3개의 멤버변수가 있고 cloaking은 없다. 하지만 wraith2 는 클래스 외부에서 직접 cloaking 이라는 멤버 변수를 정의하였고, 이는 모든 Unit 객체가 아닌 오직 wraith2 에만 해당된다.

wraith1의 멤버변수: name, hp, damage

wraith2의 멤버변수: name, hp, damage, cloaking

이와 같이 클래스로부터 객체를 만든 다음 그 객체만을 위한 멤버 변수 정의가 필요한 경우에는 클래스 외부에서 별도로 정의할 수 있으며, 이 때 이 객체를 제외한 다른 객체들은 새로 정의된 멤버 변수를 알지 못하며 사용할 수도 없다. 오직 이 객체만을 위한 멤버변수가 되는 것이다.

## 9-4. 메소드(method)

클래스에는 여러 개의 메소드를 정의할 수 있는데 일반 함수와 다른 점이라면

- 메소드는 전달값을 정의하는 부분 처음에 self를 적어준다는 점
- 메소드 내에서 self. 을 통해 클래스 멤버변수에 접근 가능하다는 점

# 10. 예외처리

# 11. 모듈과 패키지